<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.2" />
<title>response API documentation</title>
<meta name="description" content="Representing responses in a domain agnostic manner â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}#index .two-column{column-count:2}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>response</code> module</h1>
</header>
<section id="section-intro">
<p>Representing responses in a domain agnostic manner.</p>
<dl>
<dt>Implements a fluent interface.</dt>
<dt><strong><code>https</code></strong> :&ensp;//<code>en.wikipedia.org</code>/<code>wiki</code>/<code>Fluent_interface</code></dt>
<dd>&nbsp;</dd>
</dl>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;Representing responses in a domain agnostic manner.

Implements a fluent interface.
https://en.wikipedia.org/wiki/Fluent_interface
&#34;&#34;&#34;

import warnings
from fractions import Fraction
from pathlib import Path

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import get_window, resample, resample_poly, lfilter, welch
from scipy.io import wavfile

# center, lower, upper frequency
third_octave_bands = (
    (15.625, 13.920_292_470_942_801, 17.538_469_504_833_955),
    (19.686_266_404_607_39, 17.538_469_504_833_95, 22.097_086_912_079_607),
    (24.803_141_437_003_124, 22.097_086_912_079_615, 27.840_584_941_885_613),
    (31.25, 27.840_584_941_885_602, 35.076_939_009_667_91),
    (39.372_532_809_214_78, 35.076_939_009_667_9, 44.194_173_824_159_215),
    (49.606_282_874_006_25, 44.194_173_824_159_23, 55.681_169_883_771_226),
    (62.5, 55.681_169_883_771_204, 70.153_878_019_335_82),
    (78.745_065_618_429_58, 70.153_878_019_335_82, 88.388_347_648_318_44),
    (99.212_565_748_012_47, 88.388_347_648_318_43, 111.362_339_767_542_41),
    (125.0, 111.362_339_767_542_41, 140.307_756_038_671_64),
    (157.490_131_236_859_16, 140.307_756_038_671_64, 176.776_695_296_636_9),
    (198.425_131_496_024_93, 176.776_695_296_636_86, 222.724_679_535_084_82),
    (250.0, 222.724_679_535_084_82, 280.615_512_077_343_3),
    (314.980_262_473_718_3, 280.615_512_077_343_3, 353.553_390_593_273_8),
    (396.850_262_992_049_9, 353.553_390_593_273_8, 445.449_359_070_169_75),
    (500.0, 445.449_359_070_169_63, 561.231_024_154_686_6),
    (629.960_524_947_436_6, 561.231_024_154_686_6, 707.106_781_186_547_6),
    (793.700_525_984_099_8, 707.106_781_186_547_6, 890.898_718_140_339_5),
    (1000.0, 890.898_718_140_339_3, 1122.462_048_309_373_1),
    (1259.921_049_894_873_2, 1122.462_048_309_373_1, 1414.213_562_373_095),
    (1587.401_051_968_199_5, 1414.213_562_373_094_9, 1781.797_436_280_678_5),
    (2000.0, 1781.797_436_280_678_5, 2244.924_096_618_746_3),
    (2519.842_099_789_746_5, 2244.924_096_618_746_3, 2828.427_124_746_19),
    (3174.802_103_936_399_4, 2828.427_124_746_19, 3563.594_872_561_358),
    (4000.0, 3563.594_872_561_357, 4489.848_193_237_492_5),
    (5039.684_199_579_493, 4489.848_193_237_492_5, 5656.854_249_492_38),
    (6349.604_207_872_798, 5656.854_249_492_379_5, 7127.189_745_122_714),
    (8000.0, 7127.189_745_122_714, 8979.696_386_474_985),
    (10079.368_399_158_986, 8979.696_386_474_985, 11313.708_498_984_76),
    (12699.208_415_745_596, 11313.708_498_984_759, 14254.379_490_245_428),
    (16000.0, 14254.379_490_245_428, 17959.392_772_949_97),
    (20158.736_798_317_97, 17959.392_772_949_966, 22627.416_997_969_518),
)


class Response(object):
    &#34;&#34;&#34;Representation of a linear response in time and frequency domain.&#34;&#34;&#34;

    def __init__(self, fs, fdata=None, tdata=None, isEvenSampled=True, unit=None):
        &#34;&#34;&#34;Create Response from time or frequency data.

        Use `from_time` or `from_freq methods` to create objects of this class!

        Parameters
        ----------
        fs : int
            Sampling frequency in Hertz
        fdata : (ns, nr, nt) complex ndarray, optional
            Single sided frequency spectra with nt from ns to nr points.
        tdata : (ns, nr, nf) real ndarray, optional
            Time responses with nt from ns to nr points.
        isEvenSampled : bool or None, optional
            If fdata is given, this tells us if the last entry of fdata is the
            Nyquist frequency or not. Must be `None` if tdata is given.

        Raises
        ------
        ValueError
            if neither fdata or tdata are given.

        &#34;&#34;&#34;
        assert float(fs).is_integer()

        if fdata is not None and tdata is None:
            fdata = np.atleast_1d(fdata)
            self._nf = fdata.shape[-1]

            if isEvenSampled:
                self._nt = 2 * (self._nf - 1)
            else:
                self._nt = 2 * self._nf - 1
            self._isEvenSampled = isEvenSampled

            self._set_frequency_data(fdata)
        elif tdata is not None and fdata is None:
            assert np.all(np.imag(tdata) == 0), &#34;Time data must be real.&#34;
            tdata = np.atleast_1d(tdata)
            self._nt = tdata.shape[-1]
            self._nf = self._nt // 2 + 1
            self._isEvenSampled = self._nt % 2 == 0

            self._set_time_data(tdata)
        else:
            raise ValueError(&#34;One and only one of fdata and tdata must be given.&#34;)

        self._fs = int(fs)
        self._freqs = freq_vector(self._nt, fs)
        self._times = time_vector(self._nt, fs)
        self._time_length = self._nt * 1 / fs
        self._unit = unit
        self.df = self._freqs[1]  # frequency resolution
        self.dt = self._times[1]  # time resolution

    @classmethod
    def from_time(cls, fs, tdata, **kwargs):
        &#34;&#34;&#34;Generate Response obj from time response data.&#34;&#34;&#34;
        tf = cls(fs, tdata=tdata, **kwargs)
        return tf

    @classmethod
    def from_freq(cls, fs, fdata, **kwargs):
        &#34;&#34;&#34;Generate Response obj from frequency response data.&#34;&#34;&#34;
        tf = cls(fs, fdata=fdata, **kwargs)
        return tf

    @classmethod
    def from_wav(cls, fps):
        &#34;&#34;&#34;Import responses from wav files.

        Parameters
        ----------
        fps : list of file paths

        Returns
        -------
        Response
            New Response object with imported time responses.

        &#34;&#34;&#34;
        fpi = iter(fps)
        fs, data = wavfile.read(next(fpi))
        hlist = [data] + [wavfile.read(fp)[1] for fp in fpi]

        h = np.array(hlist)
        lim_orig = (np.iinfo(data.dtype).min, np.iinfo(data.dtype).max)
        lim_new = (-1.0, 1.0)
        h_float = rescale(h, lim_orig, lim_new).astype(np.double)

        return cls.from_time(fs, h_float)

    @classmethod
    def new_dirac(cls, fs, T=None, n=None, nch=(1,)):
        &#34;&#34;&#34;Generate new allpass / dirac response.&#34;&#34;&#34;
        nch = np.atleast_1d(nch)
        if T is not None:
            nt = round(fs * T)
        else:
            nt = n
        h = np.zeros((*nch, nt))
        h[..., 0] = 1
        return cls.from_time(fs, h)

    @classmethod
    def join(cls, tfs, axis=0, newaxis=True):
        &#34;&#34;&#34;Concat or stack a set of Responses along a given axis.

        Parameters
        ----------
        tfs : array_like
            List of Responses
        axis : int, optional
            Indice of axis along wich to concatenate / stack TFs.
        newaxis : bool, optional
            If True, do not concatenate but stack arrays along a new axis.

        Returns
        -------
        Response

        Note
        ----
        Transfer functions need to have same sampling rate, length etc.

        &#34;&#34;&#34;
        joinfunc = np.stack if newaxis else np.concatenate
        tdata = joinfunc([tf.in_time for tf in tfs], axis=axis)
        return cls.from_time(tfs[0].fs, tdata)

    @property
    def time_length(self):
        &#34;&#34;&#34;Length of time response in seconds.&#34;&#34;&#34;
        return self._time_length

    @property
    def nf(self):  # noqa: D401
        &#34;&#34;&#34;Number of frequencies in frequency representation.&#34;&#34;&#34;
        return len(self._freqs)

    @property
    def nt(self):  # noqa: D401
        &#34;&#34;&#34;Number of taps.&#34;&#34;&#34;
        return len(self._times)

    @property
    def fs(self):  # noqa: D401
        &#34;&#34;&#34;Sampling frequency.&#34;&#34;&#34;
        return self._fs

    @property
    def freqs(self):  # noqa: D401
        &#34;&#34;&#34;Frequencies.&#34;&#34;&#34;
        return self._freqs

    @property
    def times(self):  # noqa: D401
        &#34;&#34;&#34;Times.&#34;&#34;&#34;
        return self._times

    @property
    def in_time(self):
        &#34;&#34;&#34;Time domain response.

        Returns
        -------
        (... , n) ndarray
            Real FIR filters.

        &#34;&#34;&#34;
        if self._in_time is None:
            self._in_time = np.fft.irfft(self._in_freq, n=self._times.size)
        return self._in_time

    @property
    def in_freq(self):
        &#34;&#34;&#34;Single sided frequency spectrum.

        Returns
        -------
        (... , n) ndarray
            Complex frequency response.

        &#34;&#34;&#34;
        if self._in_freq is None:
            self._in_freq = np.fft.rfft(self._in_time)
        return self._in_freq

    @property
    def amplitude_spectrum(self):
        &#34;&#34;&#34;Amplitude spectrum.&#34;&#34;&#34;
        X = self.in_freq / self.nt

        if self.nt % 2 == 0:
            # zero and nyquist element only appear once in complex spectrum
            X[..., 1:-1] *= 2
        else:
            # there is no nyquist element
            X[..., 1:] *= 2

        return X

    def _set_time_data(self, tdata):
        &#34;&#34;&#34;Set time data without creating new object.&#34;&#34;&#34;
        assert tdata.shape[-1] == self._nt
        self._in_time = tdata
        self._in_freq = None

    def _set_frequency_data(self, fdata):
        &#34;&#34;&#34;Set frequency data without creating new object.&#34;&#34;&#34;
        assert fdata.shape[-1] == self._nf
        self._in_freq = fdata
        self._in_time = None

    def plot(
        self,
        group_delay=False,
        slce=None,
        flim=None,
        dblim=None,
        tlim=None,
        grpdlim=None,
        dbref=1,
        show=False,
        use_fig=None,
        label=None,
        unwrap=False,
        **fig_kw,
    ):
        &#34;&#34;&#34;Plot the response in both domains.

        Parameters
        ----------
        group_delay : bool, optional
            Display group delay instead of phase.
        slce : numpy.lib.index_tricks.IndexExpression
            only plot subset of responses defined by a slice. Last
            dimension (f, t) is always completely taken.
        flim : tuple or None, optional
            Frequency axes limits as tuple `(lower, upper)`
        dblim : tuple or None, optional
            Magnitude axes limits as tuple `(lower, upper)`
        tlim : tuple or None, optional
            Time axes limits as tuple `(lower, upper)`
        dbref : float
            dB reference in magnitude plot
        show : bool, optional
            Run `matplotlib.pyplot.show()`
        fig : matplotlib.pyplot.Figure
            Reuse an existing figure.
        label : None, optional
            Description
        unwrap_phase : bool, optional
            unwrap phase in phase plot
        **fig_kw
            Additional options passe to figure creation.

        &#34;&#34;&#34;
        if use_fig is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 10)}, **fig_kw}
            fig, axes = plt.subplots(nrows=3, constrained_layout=True, **fig_kw)
        else:
            fig = use_fig
            axes = fig.axes

        self.plot_magnitude(
            use_ax=axes[0], slce=slce, dblim=dblim, flim=flim, dbref=dbref, label=label
        )
        if group_delay:
            self.plot_group_delay(use_ax=axes[1], slce=slce, flim=flim, ylim=grpdlim)
        else:
            self.plot_phase(use_ax=axes[1], slce=slce, flim=flim)
        self.plot_time(use_ax=axes[2], tlim=tlim, slce=slce, unwrap=unwrap)

        if show:
            plt.show()

        return fig

    def plot_magnitude(
        self,
        use_ax=None,
        slce=None,
        dblim=None,
        flim=None,
        dbref=1,
        label=None,
        **fig_kw,
    ):
        &#34;&#34;&#34;Plot magnitude response.&#34;&#34;&#34;
        if use_ax is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
            fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
        else:
            ax = use_ax
            fig = ax.get_figure()

        # append frequency/time dimension to slice
        if slce is None:
            slce = [np.s_[:] for n in range(len(self.in_time.shape))]
        elif isinstance(slce, tuple):
            slce = slce + (np.s_[:],)
        else:
            slce = (slce, np.s_[:])

        unit = &#34; &#34; + self._unit if self._unit else &#34;&#34;

        # move time / frequency axis to first dimension
        freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
            (self.nf, -1)
        )

        ax.semilogx(
            self.freqs, 20 * np.log10(np.abs(freq_plotready / dbref)), label=label
        )
        ax.set_xlabel(&#34;Frequency [Hz]&#34;)
        ax.set_ylabel(&#34;Magnitude [dB re {:.2}{}]&#34;.format(float(dbref), unit))
        ax.set_title(&#34;Frequency response&#34;)
        ax.grid(True)

        if flim is None:
            flim = (10, self.fs / 2)
        ax.set_xlim(flim)

        return fig

    def plot_phase(
        self,
        use_ax=None,
        slce=None,
        flim=None,
        label=None,
        unwrap=False,
        ylim=None,
        **fig_kw,
    ):
        &#34;&#34;&#34;Plot phase response.&#34;&#34;&#34;
        if use_ax is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
            fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
        else:
            ax = use_ax
            fig = ax.get_figure()

        # append frequency/time dimension to slice
        if slce is None:
            slce = [np.s_[:] for n in range(len(self.in_time.shape))]
        elif isinstance(slce, tuple):
            slce = slce + (np.s_[:],)
        else:
            slce = (slce, np.s_[:])

        # move time / frequency axis to first dimension
        freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
            (self.nf, -1)
        )
        phase = (
            np.unwrap(np.angle(freq_plotready)) if unwrap else np.angle(freq_plotready)
        )

        ax.semilogx(self.freqs, phase)
        ax.set_xlabel(&#34;Frequency [Hz]&#34;)
        ax.set_ylabel(&#34;Phase [rad]&#34;)
        ax.set_title(&#34;Phase response&#34;)
        ax.grid(True)

        if flim is None:
            flim = (10, self.fs / 2)
        ax.set_xlim(flim)
        if ylim:
            ax.set_ylim(ylim)

        return fig

    def plot_time(self, use_ax=None, slce=None, tlim=None, ylim=None, **fig_kw):
        &#34;&#34;&#34;Plot time response.&#34;&#34;&#34;
        if use_ax is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
            fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
        else:
            ax = use_ax
            fig = ax.get_figure()

        # append frequency/time dimension to slice
        if slce is None:
            slce = [np.s_[:] for n in range(len(self.in_time.shape))]
        elif isinstance(slce, tuple):
            slce = slce + (np.s_[:],)
        else:
            slce = (slce, np.s_[:])

        time_plotready = np.rollaxis(self.in_time[tuple(slce)], -1).reshape(
            (self.nt, -1)
        )

        ax.plot(self.times, time_plotready)
        ax.set_xlabel(&#34;Time [s]&#34;)
        ax.set_ylabel(&#34;&#34;)
        ax.set_title(&#34;Time response&#34;)
        ax.grid(True)
        if tlim:
            ax.set_xlim(tlim)
        if ylim:
            ax.set_ylim(ylim)

        return fig

    def plot_group_delay(
        self, use_ax=None, slce=None, flim=None, label=None, ylim=None, **fig_kw
    ):
        &#34;&#34;&#34;Plot group delay.&#34;&#34;&#34;
        if use_ax is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
            fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
        else:
            ax = use_ax
            fig = ax.get_figure()

        # append frequency/time dimension to slice
        if slce is None:
            slce = [np.s_[:] for n in range(len(self.in_time.shape))]
        elif isinstance(slce, tuple):
            slce = slce + (np.s_[:],)
        else:
            slce = (slce, np.s_[:])

        # move time / frequency axis to first dimension
        freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
            (self.nf, -1)
        )

        df = self.freqs[1] - self.freqs[0]
        grpd = -np.gradient(np.unwrap(np.angle(freq_plotready)), df, axis=0)

        ax.semilogx(self.freqs, grpd)
        ax.set_xlabel(&#34;Frequency [Hz]&#34;)
        ax.set_ylabel(&#34;Delay [s]&#34;)
        ax.set_title(&#34;Group Delay&#34;)
        ax.grid(True)
        if flim is None:
            flim = (10, self.fs / 2)
        ax.set_xlim(flim)
        if ylim:
            ax.set_ylim(ylim)

        return fig

    def plot_power_in_bands(
        self, bands=None, use_ax=None, barkwargs={}, avgaxis=None, dbref=1, **figkwargs
    ):
        &#34;&#34;&#34;Plot signal&#39;s power in bands.

        Parameters
        ----------
        bands : list or None, optional
            list of tuples (f_center, f_lower, f_upper)
        **figkwargs
            Keyword arguments passed to plt.subplots

        Returns
        -------
        tuple (P, fc, fig)

        &#34;&#34;&#34;
        P, fc = self.power_in_bands(bands=bands, avgaxis=avgaxis)

        nbands = P.shape[-1]
        P = np.atleast_2d(P).reshape((-1, nbands))

        if use_ax is None:
            fig, ax = plt.subplots(**figkwargs)
        else:
            ax = use_ax
            fig = ax.get_figure()

        xticks = range(1, nbands + 1)
        for i in range(P.shape[0]):
            ax.bar(xticks, 10 * np.log10(P[i] / dbref ** 2), **barkwargs)
        ax.set_xticks(xticks)
        ax.set_xticklabels([&#34;{:.0f}&#34;.format(f) for f in fc], rotation=&#34;vertical&#34;)
        ax.grid(True)
        ax.set_xlabel(&#34;Band&#39;s center frequencies [Hz]&#34;)
        ax.set_ylabel(&#34;Power [dB]&#34;)

        return fig

    def time_window(self, startwindow, stopwindow, window=&#34;hann&#34;):
        &#34;&#34;&#34;Apply time domain windows.

        Parameters
        ----------
        startwindow : None or tuple
            Tuple (t1, t2) with beginning and end times of window opening.
        stopwindow : None or tuple
            Tuple (t1, t2) with beginning and end times of window closing.
        window : string or tuple of string and parameter values, optional
            Desired window to use. See scipy.signal.get_window for a list of
            windows and required parameters.

        Returns
        -------
        Response
            Time windowed response object

        &#34;&#34;&#34;
        n = self.times.size
        twindow = time_window(self.fs, n, startwindow, stopwindow, window=window)
        new_response = self.from_time(self.fs, self.in_time * twindow)

        return new_response

    def freq_window(self, startwindow, stopwindow, window=&#34;hann&#34;):
        &#34;&#34;&#34;Apply frequency domain window.

        Parameters
        ----------
        startwindow : None or tuple
            Tuple (t1, t2) with beginning and end frequencies of window opening.
        stopwindow : None or tuple
            Tuple (t1, t2) with beginning and end frequencies of window closing.
        window : string or tuple of string and parameter values, optional
            Desired window to use. See scipy.signal.get_window for a list of
            windows and required parameters.

        Returns
        -------
        Response
            Frequency windowed response object

        &#34;&#34;&#34;
        n = self.times.size
        fwindow = freq_window(self.fs, n, startwindow, stopwindow, window=window)
        new_response = self.from_freq(self.fs, self.in_freq * fwindow)

        return new_response

    def delay(self, dt, keep_length=True):
        &#34;&#34;&#34;Delay time response by dt seconds.

        Rounds of to closest integer delay.
        &#34;&#34;&#34;
        x = delay(self.fs, self.in_time, dt, keep_length=keep_length)
        return self.from_time(self.fs, x)

    def circdelay(self, dt):
        &#34;&#34;&#34;Delay by circular shift.

        Rounds of to closest integer delay.
        &#34;&#34;&#34;
        x = self.in_time
        n = int(round(dt * self.fs))
        shifted = np.roll(x, n, axis=-1)

        return self.from_time(self.fs, shifted)

    def timecrop(self, start, end):
        &#34;&#34;&#34;Crop time response.

        Parameters
        ----------
        start, end : float
            Start and end times in seconds. Does not include sample at t=end. Use
            end=None to force inclusion of last sample.

        Returns
        -------
        Response
            New Response object with cropped time.

        Notes
        -----
        Creates new Response object.

        The following should always hold:

        &gt;&gt;&gt; np.all(np.concatenate(
        &gt;&gt;&gt;     (
        &gt;&gt;&gt;         Response.from_time(fs, x).timecrop(0, split).in_time,
        &gt;&gt;&gt;         Response.from_time(fs, x).timecrop(split, None).in_time,
        &gt;&gt;&gt;     ),
        &gt;&gt;&gt;     axis=-1,
        &gt;&gt;&gt; ) == x)
        True

        &#34;&#34;&#34;
        if start &lt; 0:
            start += self.time_length
        if end is not None and end &lt; 0:
            end += self.time_length
        assert 0 &lt;= start &lt; self.time_length
        assert end is None or (0 &lt; end &lt;= self.time_length)

        _, i_start = find_nearest(self.times, start)
        if end is None:
            i_end = None
        else:
            _, i_end = find_nearest(self.times, end)

        print(i_start, i_end)

        h = self.in_time[..., i_start:i_end]

        new_response = self.from_time(self.fs, h)

        return new_response

    def non_causal_timecrop(self, length):
        &#34;&#34;&#34;Cut length of non-causal impulse response.

        &#34;FFT shift, cropping on both ends, iFFT shift&#34;

        Parameters
        ----------
        length : float
            final length in seconds

        Returns
        -------
        Response
            New Response object new length.

        Note
        ----
        Can introduce delay pre-delay by a sample.

        &#34;&#34;&#34;
        assert length &lt; self.time_length

        cut = (self.time_length - length) / 2

        _, i_start = find_nearest(self.times, cut)
        _, i_end = find_nearest(self.times, self.time_length - cut)

        h = np.fft.ifftshift(np.fft.fftshift(self.in_time)[..., i_start:i_end])

        new_response = self.from_time(self.fs, h)

        if new_response.time_length != length:
            w = f&#34;Could not precisely shrink to {length}s with fs = {self.fs}&#34;
            warnings.warn(w)

        return new_response

    def zeropad(self, before, after):
        &#34;&#34;&#34;Zeropad time response.

        Parameters
        ----------
        before, after : int
            Number of zero samples inserted before and after response.

        Returns
        -------
        Response
            Zeropadded response

        &#34;&#34;&#34;
        assert before % 1 == 0
        assert after % 1 == 0
        dims = self.in_time.ndim

        pad_width = [(0, 0) for n in range(dims)]
        pad_width[-1] = (int(before), int(after))

        h = np.pad(self.in_time, pad_width, &#34;constant&#34;)

        return self.from_time(self.fs, h)

    def zeropad_to_power_of_2(self):
        &#34;&#34;&#34;Pad time response for length of power of 2.

        Returns
        -------
        Response
            New response object with larger, power of 2 length.

        &#34;&#34;&#34;
        # https://stackoverflow.com/questions/14267555/find-the-smallest-power-of-2-greater-than-n-in-python
        n = 2 ** (self.nt - 1).bit_length()
        return self.zeropad(0, n - self.nt)

    def zeropad_to_length(self, n):
        &#34;&#34;&#34;Zeropad time response to length.

        Returns
        -------
        Response
            New response object with new length n.

        &#34;&#34;&#34;
        oldn = self.nt
        assert n &gt;= oldn
        return self.zeropad(0, n - oldn)

    def lowpass_by_frequency_domain_window(self, fstart, fstop):
        &#34;&#34;&#34;Lowpass response by time domain window.&#34;&#34;&#34;
        h = lowpass_by_frequency_domain_window(self.fs, self.in_time, fstart, fstop)
        return self.from_time(self.fs, h)

    def resample(self, fs_new, normalize=&#34;same_gain&#34;, window=None):
        &#34;&#34;&#34;Resample using Fourier method.

        Parameters
        ----------
        fs_new : int
            New sample rate
        normalize : str, optional
            If &#39;same_gain&#39;, normalize such that the gain is the same
            as the original signal. If &#39;same_amplitude&#39;, amplitudes will be preserved.
        window : None, optional
            Passed to scipy.signal.resample.

        Returns
        -------
        Response
            New resampled response object.

        Raises
        ------
        ValueError
            If resulting number of samples would be a non-integer.

        &#34;&#34;&#34;
        if fs_new == self.fs:
            return self

        nt_new = fs_new * self.time_length

        if nt_new % 1 != 0:
            raise ValueError(
                &#34;New number of samples must be integer, but is {}&#34;.format(nt_new)
            )

        nt_new = int(nt_new)

        h_new = resample(self.in_time, nt_new, axis=-1, window=window)

        if normalize == &#34;same_gain&#34;:
            h_new *= self.nt / nt_new
        elif normalize == &#34;same_amplitude&#34;:
            pass
        else:
            raise ValueError(
                &#34;Expected &#39;same_gain&#39; or &#39;same_amplitude&#39;, got %s&#34; % (normalize,)
            )

        return self.from_time(fs_new, h_new)

    def resample_poly(self, fs_new, normalize=&#34;same_gain&#34;, window=(&#34;kaiser&#34;, 5.0)):
        &#34;&#34;&#34;Resample using polyphase filtering.

        Parameters
        ----------
        fs_new : int
            New sample rate
        normalize : str, optional
            If &#39;same_gain&#39;, normalize such that the gain is the same
            as the original signal. If &#39;same_amplitude&#39;, amplitudes will be preserved.
        window : None, optional
            Passed to scipy.signal.resample_poly.

        Returns
        -------
        Response
            New resampled response object.

        &#34;&#34;&#34;
        if fs_new == self.fs:
            return self

        ratio = Fraction(fs_new, self.fs)
        up = ratio.numerator
        down = ratio.denominator

        if up &gt; 1000 or down &gt; 1000:
            print(&#34;Warning: resampling with high ratio {}/{}&#34;.format(up, down))

        h_new = resample_poly(self.in_time, up, down, axis=-1, window=window)

        if normalize == &#34;same_gain&#34;:
            h_new *= down / up
        elif normalize == &#34;same_amplitude&#34;:
            pass
        else:
            raise ValueError(
                &#34;Expected &#39;same_gain&#39; or &#39;same_amplitude&#39;, got %s&#34; % (normalize,)
            )

        return self.from_time(fs_new, h_new)

    def normalize(self, maxval=1):
        &#34;&#34;&#34;Normalize time response.&#34;&#34;&#34;
        h = self.in_time
        h /= np.abs(self.in_time).max()
        h *= maxval
        return self.from_time(self.fs, h)

    def export_wav(self, folder, name_fmt=&#34;{:02d}.wav&#34;, dtype=np.int16):
        &#34;&#34;&#34;Export response to wave file.

        Parameters
        ----------
        folder : file path
            Save in this folder
        name_fmt : str, optional
            Format string for file names with one placeholder, e.g. &#39;filt1{:02d}.wav&#39;.

        &#34;&#34;&#34;
        data = np.atleast_2d(self.in_time)

        assert data.ndim == 2
        assert np.all(np.abs(data) &lt;= 1.0)

        # convert and scale to new output datatype
        lim_orig = (-1.0, 1.0)
        lim_new = (np.iinfo(dtype).min, np.iinfo(dtype).max)
        data = rescale(data, lim_orig, lim_new).astype(dtype)

        for i in range(data.shape[0]):
            fp = Path(folder) / name_fmt.format(i + 1)
            wavfile.write(fp, self.fs, data[i])

    def power_in_bands(self, bands=None, avgaxis=None):
        &#34;&#34;&#34;Compute power of signal in third octave bands.

        Power(band) =   1/T  integral  |X(f)| ** 2 df
                            f in band

        Parameters
        ----------
        bands : list of tuples, length nbands optional
            Center, lower and upper frequencies of bands.

        Returns
        -------
        ndarray, shape (..., nbands)
            Power in bands

        list, length nbands
            Center frequencies of bands

        &#34;&#34;&#34;
        if bands is None:
            bands = third_octave_bands

        shape = list(self.in_freq.shape)
        shape[-1] = len(bands)
        P = np.zeros(shape)
        fcs = np.asarray([b[0] for b in bands])
        Npow2 = 2 ** (self.nt - 1).bit_length()
        f = np.fft.fftfreq(Npow2, d=1 / self.fs)
        for i, (fc, fl, fu) in enumerate(bands):
            if fu &lt; self.fs / 2:  # include only bands in frequency range
                iband = np.logical_and(fl &lt;= f, f &lt; fu)
                P[..., i] = np.sum(
                    np.abs(np.fft.fft(self.in_time, n=Npow2, axis=-1)[..., iband]) ** 2
                    * 2  # energy from negative and positive frequencies
                    * self.dt
                    / self.nt
                    / self.time_length,
                    axis=-1,
                )
            else:
                P[..., i] = 0

        if avgaxis is not None:
            P = P.mean(axis=avgaxis)

        return P, fcs

    @classmethod
    def time_vector(cls, n, fs):
        &#34;&#34;&#34;Time values of filter with n taps sampled at fs.

        Parameters
        ----------
        n : int
            number of taps in FIR filter
        fs : int
            sampling frequency in Hertz

        Returns
        -------
        (n) ndarray
            times in seconds

        &#34;&#34;&#34;
        return time_vector(n, fs)

    @classmethod
    def freq_vector(cls, n, fs, sided=&#34;single&#34;):
        &#34;&#34;&#34;Frequency values of filter with n taps sampled at fs up to Nyquist.

        Parameters
        ----------
        n : int
            Number of taps in FIR filter
        fs : int
            Sampling frequency in Hertz

        Returns
        -------
        (n // 2 + 1) ndarray
            Frequencies in Hz

        &#34;&#34;&#34;
        return freq_vector(n, fs, sided=sided)

    def filter(self, b, a):
        &#34;&#34;&#34;Filter response along one-dimension with an IIR or FIR filter.&#34;&#34;&#34;
        return self.from_time(self.fs, lfilter(b, a, self.in_time, axis=-1))

    def add_noise(self, snr, unit=None):
        &#34;&#34;&#34;Add noise to x with relative noise level SNR.

        Parameters
        ----------
        x : ndarray
            data
        SNR : float
            relative magnitude of noise, i.e. SNR = Ex/En
        unit : None or str, optional
            if &#34;dB&#34;, SNR is specified in dB, i.e. SNR = 10*log(Ex/En).

        Returns
        -------
        ndarray
            data with noise

        &#34;&#34;&#34;
        return self.from_time(self.fs, noisify(self.in_time, snr, unit=unit))

    def psd(self, **kwargs):
        &#34;&#34;&#34;Compute the power spectral density of the signal.

        Parameters
        ----------
        kwargs
            keword arguments passed to scipy.signal.welch

        Returns
        -------
        f : ndarray
            Array of sample frequencies.
        Pxx : ndarray
            Power spectral density of time signal.

        Notes
        -----
        Use scaling=&#39;density&#39; for power per bin bandwidth and scaling=&#39;spectrum&#39; for
        power per bin.

        &#34;&#34;&#34;
        return welch(self.in_time, fs=self.fs, **kwargs)


####################
# Module functions #
####################


def noisify(x, snr, unit=None):
    &#34;&#34;&#34;Add noise to x with relative noise level SNR.

    Parameters
    ----------
    x : ndarray
        data
    SNR : float
        relative magnitude of noise, i.e. SNR = Ex/En
    unit : None or str, optional
        if &#34;dB&#34;, SNR is specified in dB, i.e. SNR = 10*log(Ex/En).

    Returns
    -------
    ndarray
        data with noise

    Examples
    --------
    Add noise with 0dB SNR to a sinusoidal signal:

    &gt;&gt;&gt; t = np.linspace(0, 1, 1000000, endpoint=False)
    &gt;&gt;&gt; x = np.sin(2*np.pi*10*t)
    &gt;&gt;&gt; snr = 2
    &gt;&gt;&gt; snrdB = 10*np.log10(snr)
    &gt;&gt;&gt; xn = noisify(x, snrdB, &#34;dB&#34;)
    &gt;&gt;&gt; energy_x = np.linalg.norm(x)**2
    &gt;&gt;&gt; energy_xn = np.linalg.norm(xn)**2
    &gt;&gt;&gt; np.allclose(SNR * energy_x, energy_xn, rtol=1e-3)
    True

    TODO: add pink noise

    &#34;&#34;&#34;
    if unit == &#34;dB&#34;:
        snr = 10 ** (snr / 10)

    if np.iscomplexobj(x):
        n = np.random.standard_normal(x.shape) + 1j * np.random.standard_normal(x.shape)
    else:
        n = np.random.standard_normal(x.shape)

    n *= 1 / np.sqrt(snr) * np.linalg.norm(x) / np.linalg.norm(n)

    return x + n


def time_vector(n, fs):
    &#34;&#34;&#34;Time values of filter with n taps sampled at fs.

    Parameters
    ----------
    n : int
        number of taps in FIR filter
    fs : int
        sampling frequency in Hertz

    Returns
    -------
    (n) ndarray
        times in seconds

    &#34;&#34;&#34;
    T = 1 / fs
    return np.arange(n, dtype=float) * T  # float against int wrapping


def freq_vector(n, fs, sided=&#34;single&#34;):
    &#34;&#34;&#34;Frequency values of filter with n taps sampled at fs up to Nyquist.

    Parameters
    ----------
    n : int
        Number of taps in FIR filter
    fs : int
        Sampling frequency in Hertz

    Returns
    -------
    (n // 2 + 1) ndarray
        Frequencies in Hz

    &#34;&#34;&#34;
    # use float against int wrapping
    if sided == &#34;single&#34;:
        f = np.arange(n // 2 + 1, dtype=float) * fs / n
    elif sided == &#34;double&#34;:
        f = np.arange(n, dtype=float) * fs / n
    else:
        raise ValueError(&#34;Invalid value for sided.&#34;)

    return f


def sample_window(n, startwindow, stopwindow, window=&#34;hann&#34;):
    &#34;&#34;&#34;Create a sample domain window.&#34;&#34;&#34;
    swindow = np.ones(n)

    if startwindow is not None:
        length = startwindow[1] - startwindow[0]
        w = get_window(window, 2 * length, fftbins=False)[:length]
        swindow[: startwindow[0]] = 0
        swindow[startwindow[0] : startwindow[1]] = w

    if stopwindow is not None:
        # stop window
        length = stopwindow[1] - stopwindow[0]
        w = get_window(window, 2 * length, fftbins=False)[length:]
        swindow[stopwindow[0] + 1 : stopwindow[1] + 1] = w
        swindow[stopwindow[1] + 1 :] = 0

    return swindow


def time_window(fs, n, startwindow_t, stopwindow_t, window=&#34;hann&#34;):
    &#34;&#34;&#34;Create a time domain window.

    Negative times are relative to the end. Short cut for end time is `None`.
    &#34;&#34;&#34;
    times = time_vector(n, fs)
    T = times[-1] + times[1]  # total time length

    if startwindow_t is None:
        startwindow_n = None
    else:
        startwindow_n = []
        for t in startwindow_t:
            if t &lt; 0:
                t += T
            assert 0 &lt;= t or t &lt;= T
            startwindow_n.append(find_nearest(times, t)[1])

    if stopwindow_t is None:
        stopwindow_n = None
    else:
        stopwindow_n = []
        for t in stopwindow_t:
            if t is None:
                t = times[-1]
            elif t &lt; 0:
                t += T
            assert 0 &lt;= t or t &lt;= T
            stopwindow_n.append(find_nearest(times, t)[1])

    twindow = sample_window(n, startwindow_n, stopwindow_n, window=window)

    return twindow


def freq_window(fs, n, startwindow_f, stopwindow_f, window=&#34;hann&#34;):
    &#34;&#34;&#34;Create a frequency domain window.&#34;&#34;&#34;
    freqs = freq_vector(n, fs)

    if startwindow_f is not None:
        startwindow_n = [find_nearest(freqs, f)[1] for f in startwindow_f]
    else:
        startwindow_n = None

    if stopwindow_f is not None:
        stopwindow_n = [find_nearest(freqs, f)[1] for f in stopwindow_f]
    else:
        startwindow_n = None

    fwindow = sample_window(len(freqs), startwindow_n, stopwindow_n, window=window)

    return fwindow


def delay(fs, x, dt, keep_length=True, axis=-1):
    &#34;&#34;&#34;Delay time signal by dt seconds by inserting zeros.&#34;&#34;&#34;
    dn = int(round(dt * fs))
    n = x.shape[axis]

    if dn &gt; 0:
        # delay
        zeros_shape = list(x.shape)
        zeros_shape[axis] = dn
        zeros = np.zeros(zeros_shape)

        delayed = np.concatenate((zeros, x), axis=axis)

        if keep_length:
            # slice that takes 0 to ntaps samples along axis
            slc = [slice(None)] * len(x.shape)
            slc[axis] = slice(0, n)
            delayed = delayed[slc]

    elif dn &lt; 0:
        # pre-delay
        slc = [slice(None)] * len(x.shape)
        slc[axis] = slice(-dn, n)
        delayed = x[slc]

        if keep_length:
            zeros_shape = list(x.shape)
            zeros_shape[axis] = -dn
            zeros = np.zeros(zeros_shape)
            delayed = np.concatenate((delayed, zeros), axis=axis)
    else:
        # no delay
        delayed = x

    return delayed


def lowpass_by_frequency_domain_window(fs, x, fstart, fstop, axis=-1, window=&#34;hann&#34;):
    &#34;&#34;&#34;Lowpass by applying a frequency domain window.

    Parameters
    ----------
    fs : int
        Sampling frequency
    x : array like
        Real time domain signal
    fstart : float
        Starting frequency of window
    fstop : TYPE
        Ending frequency of window
    axis : TYPE, optional
        signal is assumed to be along x[axis]
    window : string, tuple, or array_like, optional
        Desired window to use to design the low-pass filter.

    Returns
    -------
    ndarray
        Filtered time signal

    Raises
    ------
    ValueError
        If fstart or fstop don&#39;t fit in the frequency range.

    &#34;&#34;&#34;
    n = x.shape[axis]
    f = freq_vector(n, fs)

    # corresponding indices
    _, start = find_nearest(f, fstart)
    _, stop = find_nearest(f, fstop)

    if not (start and stop):
        raise ValueError(&#34;Frequencies are to large.&#34;)

    # the window
    window_width = stop - start
    windowed_samples = np.arange(start, stop)

    symmetric_window = get_window(window, 2 * window_width, fftbins=False)
    half_window = symmetric_window[window_width:]

    # frequency domain
    X_windowed = np.fft.rfft(x, axis=axis)
    X_windowed = np.moveaxis(X_windowed, axis, 0)
    X_windowed[windowed_samples] = (
        X_windowed[windowed_samples].T * half_window.T
    ).T  # broadcasting
    X_windowed[stop:] = 0
    X_windowed = np.moveaxis(X_windowed, 0, axis)

    return np.fft.irfft(X_windowed, axis=axis, n=n)


#########
# Utils #
#########


def rescale(x, xlim, ylim):
    &#34;&#34;&#34;Rescale values to new bounds.

    Parameters
    ----------
    x : ndarray
        Values to rescale
    xlim : tuple
        Original value bounds (xmin, xmax)
    ylim : float
        New value bounds (ymin, ymax)

    Returns
    -------
    ndarray
        Rescaled values

    &#34;&#34;&#34;
    m = (ylim[1] - ylim[0]) / (xlim[1] - xlim[0])
    c = ylim[1] - m * xlim[1]
    y = m * x + c
    return y


def find_nearest(array, value):
    &#34;&#34;&#34;Find nearest value in an array and its index.

    Returns
    -------
    value
        Value of nearest entry in array
    idx
        Index of that value

    &#34;&#34;&#34;
    idx = (np.abs(array - value)).argmin()
    return array[idx], idx</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="response.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>fs, x, dt, keep_length=True, axis=-1)</span>
</code></dt>
<dd>
<section class="desc"><p>Delay time signal by dt seconds by inserting zeros.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delay(fs, x, dt, keep_length=True, axis=-1):
    &#34;&#34;&#34;Delay time signal by dt seconds by inserting zeros.&#34;&#34;&#34;
    dn = int(round(dt * fs))
    n = x.shape[axis]

    if dn &gt; 0:
        # delay
        zeros_shape = list(x.shape)
        zeros_shape[axis] = dn
        zeros = np.zeros(zeros_shape)

        delayed = np.concatenate((zeros, x), axis=axis)

        if keep_length:
            # slice that takes 0 to ntaps samples along axis
            slc = [slice(None)] * len(x.shape)
            slc[axis] = slice(0, n)
            delayed = delayed[slc]

    elif dn &lt; 0:
        # pre-delay
        slc = [slice(None)] * len(x.shape)
        slc[axis] = slice(-dn, n)
        delayed = x[slc]

        if keep_length:
            zeros_shape = list(x.shape)
            zeros_shape[axis] = -dn
            zeros = np.zeros(zeros_shape)
            delayed = np.concatenate((delayed, zeros), axis=axis)
    else:
        # no delay
        delayed = x

    return delayed</code></pre>
</details>
</dd>
<dt id="response.find_nearest"><code class="name flex">
<span>def <span class="ident">find_nearest</span></span>(<span>array, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Find nearest value in an array and its index.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Value of nearest entry in array</dd>
<dt><strong><code>idx</code></strong></dt>
<dd>Index of that value</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find_nearest(array, value):
    &#34;&#34;&#34;Find nearest value in an array and its index.

    Returns
    -------
    value
        Value of nearest entry in array
    idx
        Index of that value

    &#34;&#34;&#34;
    idx = (np.abs(array - value)).argmin()
    return array[idx], idx</code></pre>
</details>
</dd>
<dt id="response.freq_vector"><code class="name flex">
<span>def <span class="ident">freq_vector</span></span>(<span>n, fs, sided=&#39;single&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Frequency values of filter with n taps sampled at fs up to Nyquist.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of taps in FIR filter</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code></dt>
<dd>Sampling frequency in Hertz</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(n // 2 + 1) ndarray
Frequencies in Hz</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def freq_vector(n, fs, sided=&#34;single&#34;):
    &#34;&#34;&#34;Frequency values of filter with n taps sampled at fs up to Nyquist.

    Parameters
    ----------
    n : int
        Number of taps in FIR filter
    fs : int
        Sampling frequency in Hertz

    Returns
    -------
    (n // 2 + 1) ndarray
        Frequencies in Hz

    &#34;&#34;&#34;
    # use float against int wrapping
    if sided == &#34;single&#34;:
        f = np.arange(n // 2 + 1, dtype=float) * fs / n
    elif sided == &#34;double&#34;:
        f = np.arange(n, dtype=float) * fs / n
    else:
        raise ValueError(&#34;Invalid value for sided.&#34;)

    return f</code></pre>
</details>
</dd>
<dt id="response.freq_window"><code class="name flex">
<span>def <span class="ident">freq_window</span></span>(<span>fs, n, startwindow_f, stopwindow_f, window=&#39;hann&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a frequency domain window.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def freq_window(fs, n, startwindow_f, stopwindow_f, window=&#34;hann&#34;):
    &#34;&#34;&#34;Create a frequency domain window.&#34;&#34;&#34;
    freqs = freq_vector(n, fs)

    if startwindow_f is not None:
        startwindow_n = [find_nearest(freqs, f)[1] for f in startwindow_f]
    else:
        startwindow_n = None

    if stopwindow_f is not None:
        stopwindow_n = [find_nearest(freqs, f)[1] for f in stopwindow_f]
    else:
        startwindow_n = None

    fwindow = sample_window(len(freqs), startwindow_n, stopwindow_n, window=window)

    return fwindow</code></pre>
</details>
</dd>
<dt id="response.lowpass_by_frequency_domain_window"><code class="name flex">
<span>def <span class="ident">lowpass_by_frequency_domain_window</span></span>(<span>fs, x, fstart, fstop, axis=-1, window=&#39;hann&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Lowpass by applying a frequency domain window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code></dt>
<dd>Sampling frequency</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code> <code>like</code></dt>
<dd>Real time domain signal</dd>
<dt><strong><code>fstart</code></strong> :&ensp;<code>float</code></dt>
<dd>Starting frequency of window</dd>
<dt><strong><code>fstop</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>Ending frequency of window</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>signal is assumed to be along x[axis]</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>string</code>, <code>tuple</code>, or <code>array_like</code>, optional</dt>
<dd>Desired window to use to design the low-pass filter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ndarray</code></strong></dt>
<dd>Filtered time signal</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>If fstart or fstop don't fit in the frequency range.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def lowpass_by_frequency_domain_window(fs, x, fstart, fstop, axis=-1, window=&#34;hann&#34;):
    &#34;&#34;&#34;Lowpass by applying a frequency domain window.

    Parameters
    ----------
    fs : int
        Sampling frequency
    x : array like
        Real time domain signal
    fstart : float
        Starting frequency of window
    fstop : TYPE
        Ending frequency of window
    axis : TYPE, optional
        signal is assumed to be along x[axis]
    window : string, tuple, or array_like, optional
        Desired window to use to design the low-pass filter.

    Returns
    -------
    ndarray
        Filtered time signal

    Raises
    ------
    ValueError
        If fstart or fstop don&#39;t fit in the frequency range.

    &#34;&#34;&#34;
    n = x.shape[axis]
    f = freq_vector(n, fs)

    # corresponding indices
    _, start = find_nearest(f, fstart)
    _, stop = find_nearest(f, fstop)

    if not (start and stop):
        raise ValueError(&#34;Frequencies are to large.&#34;)

    # the window
    window_width = stop - start
    windowed_samples = np.arange(start, stop)

    symmetric_window = get_window(window, 2 * window_width, fftbins=False)
    half_window = symmetric_window[window_width:]

    # frequency domain
    X_windowed = np.fft.rfft(x, axis=axis)
    X_windowed = np.moveaxis(X_windowed, axis, 0)
    X_windowed[windowed_samples] = (
        X_windowed[windowed_samples].T * half_window.T
    ).T  # broadcasting
    X_windowed[stop:] = 0
    X_windowed = np.moveaxis(X_windowed, 0, axis)

    return np.fft.irfft(X_windowed, axis=axis, n=n)</code></pre>
</details>
</dd>
<dt id="response.noisify"><code class="name flex">
<span>def <span class="ident">noisify</span></span>(<span>x, snr, unit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add noise to x with relative noise level SNR.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>data</dd>
<dt><strong><code>SNR</code></strong> :&ensp;<code>float</code></dt>
<dd>relative magnitude of noise, i.e. SNR = Ex/En</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>None</code> or <code>str</code>, optional</dt>
<dd>if "dB", SNR is specified in dB, i.e. SNR = 10*log(Ex/En).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ndarray</code></strong></dt>
<dd>data with noise</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Add noise with 0dB SNR to a sinusoidal signal:</p>
<pre><code>&gt;&gt;&gt; t = np.linspace(0, 1, 1000000, endpoint=False)
&gt;&gt;&gt; x = np.sin(2*np.pi*10*t)
&gt;&gt;&gt; snr = 2
&gt;&gt;&gt; snrdB = 10*np.log10(snr)
&gt;&gt;&gt; xn = noisify(x, snrdB, "dB")
&gt;&gt;&gt; energy_x = np.linalg.norm(x)**2
&gt;&gt;&gt; energy_xn = np.linalg.norm(xn)**2
&gt;&gt;&gt; np.allclose(SNR * energy_x, energy_xn, rtol=1e-3)
True
</code></pre>
<dl>
<dt><strong><code>TODO</code></strong> :&ensp;<code>add</code> <code>pink</code> <code>noise</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def noisify(x, snr, unit=None):
    &#34;&#34;&#34;Add noise to x with relative noise level SNR.

    Parameters
    ----------
    x : ndarray
        data
    SNR : float
        relative magnitude of noise, i.e. SNR = Ex/En
    unit : None or str, optional
        if &#34;dB&#34;, SNR is specified in dB, i.e. SNR = 10*log(Ex/En).

    Returns
    -------
    ndarray
        data with noise

    Examples
    --------
    Add noise with 0dB SNR to a sinusoidal signal:

    &gt;&gt;&gt; t = np.linspace(0, 1, 1000000, endpoint=False)
    &gt;&gt;&gt; x = np.sin(2*np.pi*10*t)
    &gt;&gt;&gt; snr = 2
    &gt;&gt;&gt; snrdB = 10*np.log10(snr)
    &gt;&gt;&gt; xn = noisify(x, snrdB, &#34;dB&#34;)
    &gt;&gt;&gt; energy_x = np.linalg.norm(x)**2
    &gt;&gt;&gt; energy_xn = np.linalg.norm(xn)**2
    &gt;&gt;&gt; np.allclose(SNR * energy_x, energy_xn, rtol=1e-3)
    True

    TODO: add pink noise

    &#34;&#34;&#34;
    if unit == &#34;dB&#34;:
        snr = 10 ** (snr / 10)

    if np.iscomplexobj(x):
        n = np.random.standard_normal(x.shape) + 1j * np.random.standard_normal(x.shape)
    else:
        n = np.random.standard_normal(x.shape)

    n *= 1 / np.sqrt(snr) * np.linalg.norm(x) / np.linalg.norm(n)

    return x + n</code></pre>
</details>
</dd>
<dt id="response.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>x, xlim, ylim)</span>
</code></dt>
<dd>
<section class="desc"><p>Rescale values to new bounds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Values to rescale</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Original value bounds (xmin, xmax)</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>float</code></dt>
<dd>New value bounds (ymin, ymax)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ndarray</code></strong></dt>
<dd>Rescaled values</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rescale(x, xlim, ylim):
    &#34;&#34;&#34;Rescale values to new bounds.

    Parameters
    ----------
    x : ndarray
        Values to rescale
    xlim : tuple
        Original value bounds (xmin, xmax)
    ylim : float
        New value bounds (ymin, ymax)

    Returns
    -------
    ndarray
        Rescaled values

    &#34;&#34;&#34;
    m = (ylim[1] - ylim[0]) / (xlim[1] - xlim[0])
    c = ylim[1] - m * xlim[1]
    y = m * x + c
    return y</code></pre>
</details>
</dd>
<dt id="response.sample_window"><code class="name flex">
<span>def <span class="ident">sample_window</span></span>(<span>n, startwindow, stopwindow, window=&#39;hann&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a sample domain window.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sample_window(n, startwindow, stopwindow, window=&#34;hann&#34;):
    &#34;&#34;&#34;Create a sample domain window.&#34;&#34;&#34;
    swindow = np.ones(n)

    if startwindow is not None:
        length = startwindow[1] - startwindow[0]
        w = get_window(window, 2 * length, fftbins=False)[:length]
        swindow[: startwindow[0]] = 0
        swindow[startwindow[0] : startwindow[1]] = w

    if stopwindow is not None:
        # stop window
        length = stopwindow[1] - stopwindow[0]
        w = get_window(window, 2 * length, fftbins=False)[length:]
        swindow[stopwindow[0] + 1 : stopwindow[1] + 1] = w
        swindow[stopwindow[1] + 1 :] = 0

    return swindow</code></pre>
</details>
</dd>
<dt id="response.time_vector"><code class="name flex">
<span>def <span class="ident">time_vector</span></span>(<span>n, fs)</span>
</code></dt>
<dd>
<section class="desc"><p>Time values of filter with n taps sampled at fs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>number of taps in FIR filter</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code></dt>
<dd>sampling frequency in Hertz</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(n) ndarray
times in seconds</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def time_vector(n, fs):
    &#34;&#34;&#34;Time values of filter with n taps sampled at fs.

    Parameters
    ----------
    n : int
        number of taps in FIR filter
    fs : int
        sampling frequency in Hertz

    Returns
    -------
    (n) ndarray
        times in seconds

    &#34;&#34;&#34;
    T = 1 / fs
    return np.arange(n, dtype=float) * T  # float against int wrapping</code></pre>
</details>
</dd>
<dt id="response.time_window"><code class="name flex">
<span>def <span class="ident">time_window</span></span>(<span>fs, n, startwindow_t, stopwindow_t, window=&#39;hann&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a time domain window.</p>
<p>Negative times are relative to the end. Short cut for end time is <code>None</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def time_window(fs, n, startwindow_t, stopwindow_t, window=&#34;hann&#34;):
    &#34;&#34;&#34;Create a time domain window.

    Negative times are relative to the end. Short cut for end time is `None`.
    &#34;&#34;&#34;
    times = time_vector(n, fs)
    T = times[-1] + times[1]  # total time length

    if startwindow_t is None:
        startwindow_n = None
    else:
        startwindow_n = []
        for t in startwindow_t:
            if t &lt; 0:
                t += T
            assert 0 &lt;= t or t &lt;= T
            startwindow_n.append(find_nearest(times, t)[1])

    if stopwindow_t is None:
        stopwindow_n = None
    else:
        stopwindow_n = []
        for t in stopwindow_t:
            if t is None:
                t = times[-1]
            elif t &lt; 0:
                t += T
            assert 0 &lt;= t or t &lt;= T
            stopwindow_n.append(find_nearest(times, t)[1])

    twindow = sample_window(n, startwindow_n, stopwindow_n, window=window)

    return twindow</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="response.Response"><code class="flex name class">
<span>class <span class="ident">Response</span></span>
</code></dt>
<dd>
<section class="desc"><p>Representation of a linear response in time and frequency domain.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Response(object):
    &#34;&#34;&#34;Representation of a linear response in time and frequency domain.&#34;&#34;&#34;

    def __init__(self, fs, fdata=None, tdata=None, isEvenSampled=True, unit=None):
        &#34;&#34;&#34;Create Response from time or frequency data.

        Use `from_time` or `from_freq methods` to create objects of this class!

        Parameters
        ----------
        fs : int
            Sampling frequency in Hertz
        fdata : (ns, nr, nt) complex ndarray, optional
            Single sided frequency spectra with nt from ns to nr points.
        tdata : (ns, nr, nf) real ndarray, optional
            Time responses with nt from ns to nr points.
        isEvenSampled : bool or None, optional
            If fdata is given, this tells us if the last entry of fdata is the
            Nyquist frequency or not. Must be `None` if tdata is given.

        Raises
        ------
        ValueError
            if neither fdata or tdata are given.

        &#34;&#34;&#34;
        assert float(fs).is_integer()

        if fdata is not None and tdata is None:
            fdata = np.atleast_1d(fdata)
            self._nf = fdata.shape[-1]

            if isEvenSampled:
                self._nt = 2 * (self._nf - 1)
            else:
                self._nt = 2 * self._nf - 1
            self._isEvenSampled = isEvenSampled

            self._set_frequency_data(fdata)
        elif tdata is not None and fdata is None:
            assert np.all(np.imag(tdata) == 0), &#34;Time data must be real.&#34;
            tdata = np.atleast_1d(tdata)
            self._nt = tdata.shape[-1]
            self._nf = self._nt // 2 + 1
            self._isEvenSampled = self._nt % 2 == 0

            self._set_time_data(tdata)
        else:
            raise ValueError(&#34;One and only one of fdata and tdata must be given.&#34;)

        self._fs = int(fs)
        self._freqs = freq_vector(self._nt, fs)
        self._times = time_vector(self._nt, fs)
        self._time_length = self._nt * 1 / fs
        self._unit = unit
        self.df = self._freqs[1]  # frequency resolution
        self.dt = self._times[1]  # time resolution

    @classmethod
    def from_time(cls, fs, tdata, **kwargs):
        &#34;&#34;&#34;Generate Response obj from time response data.&#34;&#34;&#34;
        tf = cls(fs, tdata=tdata, **kwargs)
        return tf

    @classmethod
    def from_freq(cls, fs, fdata, **kwargs):
        &#34;&#34;&#34;Generate Response obj from frequency response data.&#34;&#34;&#34;
        tf = cls(fs, fdata=fdata, **kwargs)
        return tf

    @classmethod
    def from_wav(cls, fps):
        &#34;&#34;&#34;Import responses from wav files.

        Parameters
        ----------
        fps : list of file paths

        Returns
        -------
        Response
            New Response object with imported time responses.

        &#34;&#34;&#34;
        fpi = iter(fps)
        fs, data = wavfile.read(next(fpi))
        hlist = [data] + [wavfile.read(fp)[1] for fp in fpi]

        h = np.array(hlist)
        lim_orig = (np.iinfo(data.dtype).min, np.iinfo(data.dtype).max)
        lim_new = (-1.0, 1.0)
        h_float = rescale(h, lim_orig, lim_new).astype(np.double)

        return cls.from_time(fs, h_float)

    @classmethod
    def new_dirac(cls, fs, T=None, n=None, nch=(1,)):
        &#34;&#34;&#34;Generate new allpass / dirac response.&#34;&#34;&#34;
        nch = np.atleast_1d(nch)
        if T is not None:
            nt = round(fs * T)
        else:
            nt = n
        h = np.zeros((*nch, nt))
        h[..., 0] = 1
        return cls.from_time(fs, h)

    @classmethod
    def join(cls, tfs, axis=0, newaxis=True):
        &#34;&#34;&#34;Concat or stack a set of Responses along a given axis.

        Parameters
        ----------
        tfs : array_like
            List of Responses
        axis : int, optional
            Indice of axis along wich to concatenate / stack TFs.
        newaxis : bool, optional
            If True, do not concatenate but stack arrays along a new axis.

        Returns
        -------
        Response

        Note
        ----
        Transfer functions need to have same sampling rate, length etc.

        &#34;&#34;&#34;
        joinfunc = np.stack if newaxis else np.concatenate
        tdata = joinfunc([tf.in_time for tf in tfs], axis=axis)
        return cls.from_time(tfs[0].fs, tdata)

    @property
    def time_length(self):
        &#34;&#34;&#34;Length of time response in seconds.&#34;&#34;&#34;
        return self._time_length

    @property
    def nf(self):  # noqa: D401
        &#34;&#34;&#34;Number of frequencies in frequency representation.&#34;&#34;&#34;
        return len(self._freqs)

    @property
    def nt(self):  # noqa: D401
        &#34;&#34;&#34;Number of taps.&#34;&#34;&#34;
        return len(self._times)

    @property
    def fs(self):  # noqa: D401
        &#34;&#34;&#34;Sampling frequency.&#34;&#34;&#34;
        return self._fs

    @property
    def freqs(self):  # noqa: D401
        &#34;&#34;&#34;Frequencies.&#34;&#34;&#34;
        return self._freqs

    @property
    def times(self):  # noqa: D401
        &#34;&#34;&#34;Times.&#34;&#34;&#34;
        return self._times

    @property
    def in_time(self):
        &#34;&#34;&#34;Time domain response.

        Returns
        -------
        (... , n) ndarray
            Real FIR filters.

        &#34;&#34;&#34;
        if self._in_time is None:
            self._in_time = np.fft.irfft(self._in_freq, n=self._times.size)
        return self._in_time

    @property
    def in_freq(self):
        &#34;&#34;&#34;Single sided frequency spectrum.

        Returns
        -------
        (... , n) ndarray
            Complex frequency response.

        &#34;&#34;&#34;
        if self._in_freq is None:
            self._in_freq = np.fft.rfft(self._in_time)
        return self._in_freq

    @property
    def amplitude_spectrum(self):
        &#34;&#34;&#34;Amplitude spectrum.&#34;&#34;&#34;
        X = self.in_freq / self.nt

        if self.nt % 2 == 0:
            # zero and nyquist element only appear once in complex spectrum
            X[..., 1:-1] *= 2
        else:
            # there is no nyquist element
            X[..., 1:] *= 2

        return X

    def _set_time_data(self, tdata):
        &#34;&#34;&#34;Set time data without creating new object.&#34;&#34;&#34;
        assert tdata.shape[-1] == self._nt
        self._in_time = tdata
        self._in_freq = None

    def _set_frequency_data(self, fdata):
        &#34;&#34;&#34;Set frequency data without creating new object.&#34;&#34;&#34;
        assert fdata.shape[-1] == self._nf
        self._in_freq = fdata
        self._in_time = None

    def plot(
        self,
        group_delay=False,
        slce=None,
        flim=None,
        dblim=None,
        tlim=None,
        grpdlim=None,
        dbref=1,
        show=False,
        use_fig=None,
        label=None,
        unwrap=False,
        **fig_kw,
    ):
        &#34;&#34;&#34;Plot the response in both domains.

        Parameters
        ----------
        group_delay : bool, optional
            Display group delay instead of phase.
        slce : numpy.lib.index_tricks.IndexExpression
            only plot subset of responses defined by a slice. Last
            dimension (f, t) is always completely taken.
        flim : tuple or None, optional
            Frequency axes limits as tuple `(lower, upper)`
        dblim : tuple or None, optional
            Magnitude axes limits as tuple `(lower, upper)`
        tlim : tuple or None, optional
            Time axes limits as tuple `(lower, upper)`
        dbref : float
            dB reference in magnitude plot
        show : bool, optional
            Run `matplotlib.pyplot.show()`
        fig : matplotlib.pyplot.Figure
            Reuse an existing figure.
        label : None, optional
            Description
        unwrap_phase : bool, optional
            unwrap phase in phase plot
        **fig_kw
            Additional options passe to figure creation.

        &#34;&#34;&#34;
        if use_fig is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 10)}, **fig_kw}
            fig, axes = plt.subplots(nrows=3, constrained_layout=True, **fig_kw)
        else:
            fig = use_fig
            axes = fig.axes

        self.plot_magnitude(
            use_ax=axes[0], slce=slce, dblim=dblim, flim=flim, dbref=dbref, label=label
        )
        if group_delay:
            self.plot_group_delay(use_ax=axes[1], slce=slce, flim=flim, ylim=grpdlim)
        else:
            self.plot_phase(use_ax=axes[1], slce=slce, flim=flim)
        self.plot_time(use_ax=axes[2], tlim=tlim, slce=slce, unwrap=unwrap)

        if show:
            plt.show()

        return fig

    def plot_magnitude(
        self,
        use_ax=None,
        slce=None,
        dblim=None,
        flim=None,
        dbref=1,
        label=None,
        **fig_kw,
    ):
        &#34;&#34;&#34;Plot magnitude response.&#34;&#34;&#34;
        if use_ax is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
            fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
        else:
            ax = use_ax
            fig = ax.get_figure()

        # append frequency/time dimension to slice
        if slce is None:
            slce = [np.s_[:] for n in range(len(self.in_time.shape))]
        elif isinstance(slce, tuple):
            slce = slce + (np.s_[:],)
        else:
            slce = (slce, np.s_[:])

        unit = &#34; &#34; + self._unit if self._unit else &#34;&#34;

        # move time / frequency axis to first dimension
        freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
            (self.nf, -1)
        )

        ax.semilogx(
            self.freqs, 20 * np.log10(np.abs(freq_plotready / dbref)), label=label
        )
        ax.set_xlabel(&#34;Frequency [Hz]&#34;)
        ax.set_ylabel(&#34;Magnitude [dB re {:.2}{}]&#34;.format(float(dbref), unit))
        ax.set_title(&#34;Frequency response&#34;)
        ax.grid(True)

        if flim is None:
            flim = (10, self.fs / 2)
        ax.set_xlim(flim)

        return fig

    def plot_phase(
        self,
        use_ax=None,
        slce=None,
        flim=None,
        label=None,
        unwrap=False,
        ylim=None,
        **fig_kw,
    ):
        &#34;&#34;&#34;Plot phase response.&#34;&#34;&#34;
        if use_ax is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
            fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
        else:
            ax = use_ax
            fig = ax.get_figure()

        # append frequency/time dimension to slice
        if slce is None:
            slce = [np.s_[:] for n in range(len(self.in_time.shape))]
        elif isinstance(slce, tuple):
            slce = slce + (np.s_[:],)
        else:
            slce = (slce, np.s_[:])

        # move time / frequency axis to first dimension
        freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
            (self.nf, -1)
        )
        phase = (
            np.unwrap(np.angle(freq_plotready)) if unwrap else np.angle(freq_plotready)
        )

        ax.semilogx(self.freqs, phase)
        ax.set_xlabel(&#34;Frequency [Hz]&#34;)
        ax.set_ylabel(&#34;Phase [rad]&#34;)
        ax.set_title(&#34;Phase response&#34;)
        ax.grid(True)

        if flim is None:
            flim = (10, self.fs / 2)
        ax.set_xlim(flim)
        if ylim:
            ax.set_ylim(ylim)

        return fig

    def plot_time(self, use_ax=None, slce=None, tlim=None, ylim=None, **fig_kw):
        &#34;&#34;&#34;Plot time response.&#34;&#34;&#34;
        if use_ax is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
            fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
        else:
            ax = use_ax
            fig = ax.get_figure()

        # append frequency/time dimension to slice
        if slce is None:
            slce = [np.s_[:] for n in range(len(self.in_time.shape))]
        elif isinstance(slce, tuple):
            slce = slce + (np.s_[:],)
        else:
            slce = (slce, np.s_[:])

        time_plotready = np.rollaxis(self.in_time[tuple(slce)], -1).reshape(
            (self.nt, -1)
        )

        ax.plot(self.times, time_plotready)
        ax.set_xlabel(&#34;Time [s]&#34;)
        ax.set_ylabel(&#34;&#34;)
        ax.set_title(&#34;Time response&#34;)
        ax.grid(True)
        if tlim:
            ax.set_xlim(tlim)
        if ylim:
            ax.set_ylim(ylim)

        return fig

    def plot_group_delay(
        self, use_ax=None, slce=None, flim=None, label=None, ylim=None, **fig_kw
    ):
        &#34;&#34;&#34;Plot group delay.&#34;&#34;&#34;
        if use_ax is None:
            fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
            fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
        else:
            ax = use_ax
            fig = ax.get_figure()

        # append frequency/time dimension to slice
        if slce is None:
            slce = [np.s_[:] for n in range(len(self.in_time.shape))]
        elif isinstance(slce, tuple):
            slce = slce + (np.s_[:],)
        else:
            slce = (slce, np.s_[:])

        # move time / frequency axis to first dimension
        freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
            (self.nf, -1)
        )

        df = self.freqs[1] - self.freqs[0]
        grpd = -np.gradient(np.unwrap(np.angle(freq_plotready)), df, axis=0)

        ax.semilogx(self.freqs, grpd)
        ax.set_xlabel(&#34;Frequency [Hz]&#34;)
        ax.set_ylabel(&#34;Delay [s]&#34;)
        ax.set_title(&#34;Group Delay&#34;)
        ax.grid(True)
        if flim is None:
            flim = (10, self.fs / 2)
        ax.set_xlim(flim)
        if ylim:
            ax.set_ylim(ylim)

        return fig

    def plot_power_in_bands(
        self, bands=None, use_ax=None, barkwargs={}, avgaxis=None, dbref=1, **figkwargs
    ):
        &#34;&#34;&#34;Plot signal&#39;s power in bands.

        Parameters
        ----------
        bands : list or None, optional
            list of tuples (f_center, f_lower, f_upper)
        **figkwargs
            Keyword arguments passed to plt.subplots

        Returns
        -------
        tuple (P, fc, fig)

        &#34;&#34;&#34;
        P, fc = self.power_in_bands(bands=bands, avgaxis=avgaxis)

        nbands = P.shape[-1]
        P = np.atleast_2d(P).reshape((-1, nbands))

        if use_ax is None:
            fig, ax = plt.subplots(**figkwargs)
        else:
            ax = use_ax
            fig = ax.get_figure()

        xticks = range(1, nbands + 1)
        for i in range(P.shape[0]):
            ax.bar(xticks, 10 * np.log10(P[i] / dbref ** 2), **barkwargs)
        ax.set_xticks(xticks)
        ax.set_xticklabels([&#34;{:.0f}&#34;.format(f) for f in fc], rotation=&#34;vertical&#34;)
        ax.grid(True)
        ax.set_xlabel(&#34;Band&#39;s center frequencies [Hz]&#34;)
        ax.set_ylabel(&#34;Power [dB]&#34;)

        return fig

    def time_window(self, startwindow, stopwindow, window=&#34;hann&#34;):
        &#34;&#34;&#34;Apply time domain windows.

        Parameters
        ----------
        startwindow : None or tuple
            Tuple (t1, t2) with beginning and end times of window opening.
        stopwindow : None or tuple
            Tuple (t1, t2) with beginning and end times of window closing.
        window : string or tuple of string and parameter values, optional
            Desired window to use. See scipy.signal.get_window for a list of
            windows and required parameters.

        Returns
        -------
        Response
            Time windowed response object

        &#34;&#34;&#34;
        n = self.times.size
        twindow = time_window(self.fs, n, startwindow, stopwindow, window=window)
        new_response = self.from_time(self.fs, self.in_time * twindow)

        return new_response

    def freq_window(self, startwindow, stopwindow, window=&#34;hann&#34;):
        &#34;&#34;&#34;Apply frequency domain window.

        Parameters
        ----------
        startwindow : None or tuple
            Tuple (t1, t2) with beginning and end frequencies of window opening.
        stopwindow : None or tuple
            Tuple (t1, t2) with beginning and end frequencies of window closing.
        window : string or tuple of string and parameter values, optional
            Desired window to use. See scipy.signal.get_window for a list of
            windows and required parameters.

        Returns
        -------
        Response
            Frequency windowed response object

        &#34;&#34;&#34;
        n = self.times.size
        fwindow = freq_window(self.fs, n, startwindow, stopwindow, window=window)
        new_response = self.from_freq(self.fs, self.in_freq * fwindow)

        return new_response

    def delay(self, dt, keep_length=True):
        &#34;&#34;&#34;Delay time response by dt seconds.

        Rounds of to closest integer delay.
        &#34;&#34;&#34;
        x = delay(self.fs, self.in_time, dt, keep_length=keep_length)
        return self.from_time(self.fs, x)

    def circdelay(self, dt):
        &#34;&#34;&#34;Delay by circular shift.

        Rounds of to closest integer delay.
        &#34;&#34;&#34;
        x = self.in_time
        n = int(round(dt * self.fs))
        shifted = np.roll(x, n, axis=-1)

        return self.from_time(self.fs, shifted)

    def timecrop(self, start, end):
        &#34;&#34;&#34;Crop time response.

        Parameters
        ----------
        start, end : float
            Start and end times in seconds. Does not include sample at t=end. Use
            end=None to force inclusion of last sample.

        Returns
        -------
        Response
            New Response object with cropped time.

        Notes
        -----
        Creates new Response object.

        The following should always hold:

        &gt;&gt;&gt; np.all(np.concatenate(
        &gt;&gt;&gt;     (
        &gt;&gt;&gt;         Response.from_time(fs, x).timecrop(0, split).in_time,
        &gt;&gt;&gt;         Response.from_time(fs, x).timecrop(split, None).in_time,
        &gt;&gt;&gt;     ),
        &gt;&gt;&gt;     axis=-1,
        &gt;&gt;&gt; ) == x)
        True

        &#34;&#34;&#34;
        if start &lt; 0:
            start += self.time_length
        if end is not None and end &lt; 0:
            end += self.time_length
        assert 0 &lt;= start &lt; self.time_length
        assert end is None or (0 &lt; end &lt;= self.time_length)

        _, i_start = find_nearest(self.times, start)
        if end is None:
            i_end = None
        else:
            _, i_end = find_nearest(self.times, end)

        print(i_start, i_end)

        h = self.in_time[..., i_start:i_end]

        new_response = self.from_time(self.fs, h)

        return new_response

    def non_causal_timecrop(self, length):
        &#34;&#34;&#34;Cut length of non-causal impulse response.

        &#34;FFT shift, cropping on both ends, iFFT shift&#34;

        Parameters
        ----------
        length : float
            final length in seconds

        Returns
        -------
        Response
            New Response object new length.

        Note
        ----
        Can introduce delay pre-delay by a sample.

        &#34;&#34;&#34;
        assert length &lt; self.time_length

        cut = (self.time_length - length) / 2

        _, i_start = find_nearest(self.times, cut)
        _, i_end = find_nearest(self.times, self.time_length - cut)

        h = np.fft.ifftshift(np.fft.fftshift(self.in_time)[..., i_start:i_end])

        new_response = self.from_time(self.fs, h)

        if new_response.time_length != length:
            w = f&#34;Could not precisely shrink to {length}s with fs = {self.fs}&#34;
            warnings.warn(w)

        return new_response

    def zeropad(self, before, after):
        &#34;&#34;&#34;Zeropad time response.

        Parameters
        ----------
        before, after : int
            Number of zero samples inserted before and after response.

        Returns
        -------
        Response
            Zeropadded response

        &#34;&#34;&#34;
        assert before % 1 == 0
        assert after % 1 == 0
        dims = self.in_time.ndim

        pad_width = [(0, 0) for n in range(dims)]
        pad_width[-1] = (int(before), int(after))

        h = np.pad(self.in_time, pad_width, &#34;constant&#34;)

        return self.from_time(self.fs, h)

    def zeropad_to_power_of_2(self):
        &#34;&#34;&#34;Pad time response for length of power of 2.

        Returns
        -------
        Response
            New response object with larger, power of 2 length.

        &#34;&#34;&#34;
        # https://stackoverflow.com/questions/14267555/find-the-smallest-power-of-2-greater-than-n-in-python
        n = 2 ** (self.nt - 1).bit_length()
        return self.zeropad(0, n - self.nt)

    def zeropad_to_length(self, n):
        &#34;&#34;&#34;Zeropad time response to length.

        Returns
        -------
        Response
            New response object with new length n.

        &#34;&#34;&#34;
        oldn = self.nt
        assert n &gt;= oldn
        return self.zeropad(0, n - oldn)

    def lowpass_by_frequency_domain_window(self, fstart, fstop):
        &#34;&#34;&#34;Lowpass response by time domain window.&#34;&#34;&#34;
        h = lowpass_by_frequency_domain_window(self.fs, self.in_time, fstart, fstop)
        return self.from_time(self.fs, h)

    def resample(self, fs_new, normalize=&#34;same_gain&#34;, window=None):
        &#34;&#34;&#34;Resample using Fourier method.

        Parameters
        ----------
        fs_new : int
            New sample rate
        normalize : str, optional
            If &#39;same_gain&#39;, normalize such that the gain is the same
            as the original signal. If &#39;same_amplitude&#39;, amplitudes will be preserved.
        window : None, optional
            Passed to scipy.signal.resample.

        Returns
        -------
        Response
            New resampled response object.

        Raises
        ------
        ValueError
            If resulting number of samples would be a non-integer.

        &#34;&#34;&#34;
        if fs_new == self.fs:
            return self

        nt_new = fs_new * self.time_length

        if nt_new % 1 != 0:
            raise ValueError(
                &#34;New number of samples must be integer, but is {}&#34;.format(nt_new)
            )

        nt_new = int(nt_new)

        h_new = resample(self.in_time, nt_new, axis=-1, window=window)

        if normalize == &#34;same_gain&#34;:
            h_new *= self.nt / nt_new
        elif normalize == &#34;same_amplitude&#34;:
            pass
        else:
            raise ValueError(
                &#34;Expected &#39;same_gain&#39; or &#39;same_amplitude&#39;, got %s&#34; % (normalize,)
            )

        return self.from_time(fs_new, h_new)

    def resample_poly(self, fs_new, normalize=&#34;same_gain&#34;, window=(&#34;kaiser&#34;, 5.0)):
        &#34;&#34;&#34;Resample using polyphase filtering.

        Parameters
        ----------
        fs_new : int
            New sample rate
        normalize : str, optional
            If &#39;same_gain&#39;, normalize such that the gain is the same
            as the original signal. If &#39;same_amplitude&#39;, amplitudes will be preserved.
        window : None, optional
            Passed to scipy.signal.resample_poly.

        Returns
        -------
        Response
            New resampled response object.

        &#34;&#34;&#34;
        if fs_new == self.fs:
            return self

        ratio = Fraction(fs_new, self.fs)
        up = ratio.numerator
        down = ratio.denominator

        if up &gt; 1000 or down &gt; 1000:
            print(&#34;Warning: resampling with high ratio {}/{}&#34;.format(up, down))

        h_new = resample_poly(self.in_time, up, down, axis=-1, window=window)

        if normalize == &#34;same_gain&#34;:
            h_new *= down / up
        elif normalize == &#34;same_amplitude&#34;:
            pass
        else:
            raise ValueError(
                &#34;Expected &#39;same_gain&#39; or &#39;same_amplitude&#39;, got %s&#34; % (normalize,)
            )

        return self.from_time(fs_new, h_new)

    def normalize(self, maxval=1):
        &#34;&#34;&#34;Normalize time response.&#34;&#34;&#34;
        h = self.in_time
        h /= np.abs(self.in_time).max()
        h *= maxval
        return self.from_time(self.fs, h)

    def export_wav(self, folder, name_fmt=&#34;{:02d}.wav&#34;, dtype=np.int16):
        &#34;&#34;&#34;Export response to wave file.

        Parameters
        ----------
        folder : file path
            Save in this folder
        name_fmt : str, optional
            Format string for file names with one placeholder, e.g. &#39;filt1{:02d}.wav&#39;.

        &#34;&#34;&#34;
        data = np.atleast_2d(self.in_time)

        assert data.ndim == 2
        assert np.all(np.abs(data) &lt;= 1.0)

        # convert and scale to new output datatype
        lim_orig = (-1.0, 1.0)
        lim_new = (np.iinfo(dtype).min, np.iinfo(dtype).max)
        data = rescale(data, lim_orig, lim_new).astype(dtype)

        for i in range(data.shape[0]):
            fp = Path(folder) / name_fmt.format(i + 1)
            wavfile.write(fp, self.fs, data[i])

    def power_in_bands(self, bands=None, avgaxis=None):
        &#34;&#34;&#34;Compute power of signal in third octave bands.

        Power(band) =   1/T  integral  |X(f)| ** 2 df
                            f in band

        Parameters
        ----------
        bands : list of tuples, length nbands optional
            Center, lower and upper frequencies of bands.

        Returns
        -------
        ndarray, shape (..., nbands)
            Power in bands

        list, length nbands
            Center frequencies of bands

        &#34;&#34;&#34;
        if bands is None:
            bands = third_octave_bands

        shape = list(self.in_freq.shape)
        shape[-1] = len(bands)
        P = np.zeros(shape)
        fcs = np.asarray([b[0] for b in bands])
        Npow2 = 2 ** (self.nt - 1).bit_length()
        f = np.fft.fftfreq(Npow2, d=1 / self.fs)
        for i, (fc, fl, fu) in enumerate(bands):
            if fu &lt; self.fs / 2:  # include only bands in frequency range
                iband = np.logical_and(fl &lt;= f, f &lt; fu)
                P[..., i] = np.sum(
                    np.abs(np.fft.fft(self.in_time, n=Npow2, axis=-1)[..., iband]) ** 2
                    * 2  # energy from negative and positive frequencies
                    * self.dt
                    / self.nt
                    / self.time_length,
                    axis=-1,
                )
            else:
                P[..., i] = 0

        if avgaxis is not None:
            P = P.mean(axis=avgaxis)

        return P, fcs

    @classmethod
    def time_vector(cls, n, fs):
        &#34;&#34;&#34;Time values of filter with n taps sampled at fs.

        Parameters
        ----------
        n : int
            number of taps in FIR filter
        fs : int
            sampling frequency in Hertz

        Returns
        -------
        (n) ndarray
            times in seconds

        &#34;&#34;&#34;
        return time_vector(n, fs)

    @classmethod
    def freq_vector(cls, n, fs, sided=&#34;single&#34;):
        &#34;&#34;&#34;Frequency values of filter with n taps sampled at fs up to Nyquist.

        Parameters
        ----------
        n : int
            Number of taps in FIR filter
        fs : int
            Sampling frequency in Hertz

        Returns
        -------
        (n // 2 + 1) ndarray
            Frequencies in Hz

        &#34;&#34;&#34;
        return freq_vector(n, fs, sided=sided)

    def filter(self, b, a):
        &#34;&#34;&#34;Filter response along one-dimension with an IIR or FIR filter.&#34;&#34;&#34;
        return self.from_time(self.fs, lfilter(b, a, self.in_time, axis=-1))

    def add_noise(self, snr, unit=None):
        &#34;&#34;&#34;Add noise to x with relative noise level SNR.

        Parameters
        ----------
        x : ndarray
            data
        SNR : float
            relative magnitude of noise, i.e. SNR = Ex/En
        unit : None or str, optional
            if &#34;dB&#34;, SNR is specified in dB, i.e. SNR = 10*log(Ex/En).

        Returns
        -------
        ndarray
            data with noise

        &#34;&#34;&#34;
        return self.from_time(self.fs, noisify(self.in_time, snr, unit=unit))

    def psd(self, **kwargs):
        &#34;&#34;&#34;Compute the power spectral density of the signal.

        Parameters
        ----------
        kwargs
            keword arguments passed to scipy.signal.welch

        Returns
        -------
        f : ndarray
            Array of sample frequencies.
        Pxx : ndarray
            Power spectral density of time signal.

        Notes
        -----
        Use scaling=&#39;density&#39; for power per bin bandwidth and scaling=&#39;spectrum&#39; for
        power per bin.

        &#34;&#34;&#34;
        return welch(self.in_time, fs=self.fs, **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="response.Response.freq_vector"><code class="name flex">
<span>def <span class="ident">freq_vector</span></span>(<span>cls, n, fs, sided=&#39;single&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Frequency values of filter with n taps sampled at fs up to Nyquist.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of taps in FIR filter</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code></dt>
<dd>Sampling frequency in Hertz</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(n // 2 + 1) ndarray
Frequencies in Hz</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def freq_vector(cls, n, fs, sided=&#34;single&#34;):
    &#34;&#34;&#34;Frequency values of filter with n taps sampled at fs up to Nyquist.

    Parameters
    ----------
    n : int
        Number of taps in FIR filter
    fs : int
        Sampling frequency in Hertz

    Returns
    -------
    (n // 2 + 1) ndarray
        Frequencies in Hz

    &#34;&#34;&#34;
    return freq_vector(n, fs, sided=sided)</code></pre>
</details>
</dd>
<dt id="response.Response.from_freq"><code class="name flex">
<span>def <span class="ident">from_freq</span></span>(<span>cls, fs, fdata, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate Response obj from frequency response data.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def from_freq(cls, fs, fdata, **kwargs):
    &#34;&#34;&#34;Generate Response obj from frequency response data.&#34;&#34;&#34;
    tf = cls(fs, fdata=fdata, **kwargs)
    return tf</code></pre>
</details>
</dd>
<dt id="response.Response.from_time"><code class="name flex">
<span>def <span class="ident">from_time</span></span>(<span>cls, fs, tdata, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate Response obj from time response data.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def from_time(cls, fs, tdata, **kwargs):
    &#34;&#34;&#34;Generate Response obj from time response data.&#34;&#34;&#34;
    tf = cls(fs, tdata=tdata, **kwargs)
    return tf</code></pre>
</details>
</dd>
<dt id="response.Response.from_wav"><code class="name flex">
<span>def <span class="ident">from_wav</span></span>(<span>cls, fps)</span>
</code></dt>
<dd>
<section class="desc"><p>Import responses from wav files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fps</code></strong> :&ensp;<code>list</code> of <code>file</code> <code>paths</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>New Response object with imported time responses.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def from_wav(cls, fps):
    &#34;&#34;&#34;Import responses from wav files.

    Parameters
    ----------
    fps : list of file paths

    Returns
    -------
    Response
        New Response object with imported time responses.

    &#34;&#34;&#34;
    fpi = iter(fps)
    fs, data = wavfile.read(next(fpi))
    hlist = [data] + [wavfile.read(fp)[1] for fp in fpi]

    h = np.array(hlist)
    lim_orig = (np.iinfo(data.dtype).min, np.iinfo(data.dtype).max)
    lim_new = (-1.0, 1.0)
    h_float = rescale(h, lim_orig, lim_new).astype(np.double)

    return cls.from_time(fs, h_float)</code></pre>
</details>
</dd>
<dt id="response.Response.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>cls, tfs, axis=0, newaxis=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Concat or stack a set of Responses along a given axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tfs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>List of Responses</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Indice of axis along wich to concatenate / stack TFs.</dd>
<dt><strong><code>newaxis</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, do not concatenate but stack arrays along a new axis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Response</p>
<h2 id="note">Note</h2>
<p>Transfer functions need to have same sampling rate, length etc.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def join(cls, tfs, axis=0, newaxis=True):
    &#34;&#34;&#34;Concat or stack a set of Responses along a given axis.

    Parameters
    ----------
    tfs : array_like
        List of Responses
    axis : int, optional
        Indice of axis along wich to concatenate / stack TFs.
    newaxis : bool, optional
        If True, do not concatenate but stack arrays along a new axis.

    Returns
    -------
    Response

    Note
    ----
    Transfer functions need to have same sampling rate, length etc.

    &#34;&#34;&#34;
    joinfunc = np.stack if newaxis else np.concatenate
    tdata = joinfunc([tf.in_time for tf in tfs], axis=axis)
    return cls.from_time(tfs[0].fs, tdata)</code></pre>
</details>
</dd>
<dt id="response.Response.new_dirac"><code class="name flex">
<span>def <span class="ident">new_dirac</span></span>(<span>cls, fs, T=None, n=None, nch=(1,))</span>
</code></dt>
<dd>
<section class="desc"><p>Generate new allpass / dirac response.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def new_dirac(cls, fs, T=None, n=None, nch=(1,)):
    &#34;&#34;&#34;Generate new allpass / dirac response.&#34;&#34;&#34;
    nch = np.atleast_1d(nch)
    if T is not None:
        nt = round(fs * T)
    else:
        nt = n
    h = np.zeros((*nch, nt))
    h[..., 0] = 1
    return cls.from_time(fs, h)</code></pre>
</details>
</dd>
<dt id="response.Response.time_vector"><code class="name flex">
<span>def <span class="ident">time_vector</span></span>(<span>cls, n, fs)</span>
</code></dt>
<dd>
<section class="desc"><p>Time values of filter with n taps sampled at fs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>number of taps in FIR filter</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code></dt>
<dd>sampling frequency in Hertz</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(n) ndarray
times in seconds</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def time_vector(cls, n, fs):
    &#34;&#34;&#34;Time values of filter with n taps sampled at fs.

    Parameters
    ----------
    n : int
        number of taps in FIR filter
    fs : int
        sampling frequency in Hertz

    Returns
    -------
    (n) ndarray
        times in seconds

    &#34;&#34;&#34;
    return time_vector(n, fs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="response.Response.amplitude_spectrum"><code class="name">var <span class="ident">amplitude_spectrum</span></code></dt>
<dd>
<section class="desc"><p>Amplitude spectrum.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def amplitude_spectrum(self):
    &#34;&#34;&#34;Amplitude spectrum.&#34;&#34;&#34;
    X = self.in_freq / self.nt

    if self.nt % 2 == 0:
        # zero and nyquist element only appear once in complex spectrum
        X[..., 1:-1] *= 2
    else:
        # there is no nyquist element
        X[..., 1:] *= 2

    return X</code></pre>
</details>
</dd>
<dt id="response.Response.freqs"><code class="name">var <span class="ident">freqs</span></code></dt>
<dd>
<section class="desc"><p>Frequencies.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def freqs(self):  # noqa: D401
    &#34;&#34;&#34;Frequencies.&#34;&#34;&#34;
    return self._freqs</code></pre>
</details>
</dd>
<dt id="response.Response.fs"><code class="name">var <span class="ident">fs</span></code></dt>
<dd>
<section class="desc"><p>Sampling frequency.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def fs(self):  # noqa: D401
    &#34;&#34;&#34;Sampling frequency.&#34;&#34;&#34;
    return self._fs</code></pre>
</details>
</dd>
<dt id="response.Response.in_freq"><code class="name">var <span class="ident">in_freq</span></code></dt>
<dd>
<section class="desc"><p>Single sided frequency spectrum.</p>
<h2 id="returns">Returns</h2>
<p>(&hellip; , n) ndarray
Complex frequency response.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def in_freq(self):
    &#34;&#34;&#34;Single sided frequency spectrum.

    Returns
    -------
    (... , n) ndarray
        Complex frequency response.

    &#34;&#34;&#34;
    if self._in_freq is None:
        self._in_freq = np.fft.rfft(self._in_time)
    return self._in_freq</code></pre>
</details>
</dd>
<dt id="response.Response.in_time"><code class="name">var <span class="ident">in_time</span></code></dt>
<dd>
<section class="desc"><p>Time domain response.</p>
<h2 id="returns">Returns</h2>
<p>(&hellip; , n) ndarray
Real FIR filters.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def in_time(self):
    &#34;&#34;&#34;Time domain response.

    Returns
    -------
    (... , n) ndarray
        Real FIR filters.

    &#34;&#34;&#34;
    if self._in_time is None:
        self._in_time = np.fft.irfft(self._in_freq, n=self._times.size)
    return self._in_time</code></pre>
</details>
</dd>
<dt id="response.Response.nf"><code class="name">var <span class="ident">nf</span></code></dt>
<dd>
<section class="desc"><p>Number of frequencies in frequency representation.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def nf(self):  # noqa: D401
    &#34;&#34;&#34;Number of frequencies in frequency representation.&#34;&#34;&#34;
    return len(self._freqs)</code></pre>
</details>
</dd>
<dt id="response.Response.nt"><code class="name">var <span class="ident">nt</span></code></dt>
<dd>
<section class="desc"><p>Number of taps.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def nt(self):  # noqa: D401
    &#34;&#34;&#34;Number of taps.&#34;&#34;&#34;
    return len(self._times)</code></pre>
</details>
</dd>
<dt id="response.Response.time_length"><code class="name">var <span class="ident">time_length</span></code></dt>
<dd>
<section class="desc"><p>Length of time response in seconds.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def time_length(self):
    &#34;&#34;&#34;Length of time response in seconds.&#34;&#34;&#34;
    return self._time_length</code></pre>
</details>
</dd>
<dt id="response.Response.times"><code class="name">var <span class="ident">times</span></code></dt>
<dd>
<section class="desc"><p>Times.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def times(self):  # noqa: D401
    &#34;&#34;&#34;Times.&#34;&#34;&#34;
    return self._times</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="response.Response.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, fs, fdata=None, tdata=None, isEvenSampled=True, unit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create Response from time or frequency data.</p>
<p>Use <code>from_time</code> or <code>from_freq methods</code> to create objects of this class!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code></dt>
<dd>Sampling frequency in Hertz</dd>
<dt><strong><code>fdata</code></strong> :&ensp;(<code>ns</code>, <code>nr</code>, <code>nt</code>) <code>complex</code> <code>ndarray</code>, optional</dt>
<dd>Single sided frequency spectra with nt from ns to nr points.</dd>
<dt><strong><code>tdata</code></strong> :&ensp;(<code>ns</code>, <code>nr</code>, <code>nf</code>) <code>real</code> <code>ndarray</code>, optional</dt>
<dd>Time responses with nt from ns to nr points.</dd>
<dt><strong><code>isEvenSampled</code></strong> :&ensp;<code>bool</code> or <code>None</code>, optional</dt>
<dd>If fdata is given, this tells us if the last entry of fdata is the
Nyquist frequency or not. Must be <code>None</code> if tdata is given.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>if neither fdata or tdata are given.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, fs, fdata=None, tdata=None, isEvenSampled=True, unit=None):
    &#34;&#34;&#34;Create Response from time or frequency data.

    Use `from_time` or `from_freq methods` to create objects of this class!

    Parameters
    ----------
    fs : int
        Sampling frequency in Hertz
    fdata : (ns, nr, nt) complex ndarray, optional
        Single sided frequency spectra with nt from ns to nr points.
    tdata : (ns, nr, nf) real ndarray, optional
        Time responses with nt from ns to nr points.
    isEvenSampled : bool or None, optional
        If fdata is given, this tells us if the last entry of fdata is the
        Nyquist frequency or not. Must be `None` if tdata is given.

    Raises
    ------
    ValueError
        if neither fdata or tdata are given.

    &#34;&#34;&#34;
    assert float(fs).is_integer()

    if fdata is not None and tdata is None:
        fdata = np.atleast_1d(fdata)
        self._nf = fdata.shape[-1]

        if isEvenSampled:
            self._nt = 2 * (self._nf - 1)
        else:
            self._nt = 2 * self._nf - 1
        self._isEvenSampled = isEvenSampled

        self._set_frequency_data(fdata)
    elif tdata is not None and fdata is None:
        assert np.all(np.imag(tdata) == 0), &#34;Time data must be real.&#34;
        tdata = np.atleast_1d(tdata)
        self._nt = tdata.shape[-1]
        self._nf = self._nt // 2 + 1
        self._isEvenSampled = self._nt % 2 == 0

        self._set_time_data(tdata)
    else:
        raise ValueError(&#34;One and only one of fdata and tdata must be given.&#34;)

    self._fs = int(fs)
    self._freqs = freq_vector(self._nt, fs)
    self._times = time_vector(self._nt, fs)
    self._time_length = self._nt * 1 / fs
    self._unit = unit
    self.df = self._freqs[1]  # frequency resolution
    self.dt = self._times[1]  # time resolution</code></pre>
</details>
</dd>
<dt id="response.Response.add_noise"><code class="name flex">
<span>def <span class="ident">add_noise</span></span>(<span>self, snr, unit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add noise to x with relative noise level SNR.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>data</dd>
<dt><strong><code>SNR</code></strong> :&ensp;<code>float</code></dt>
<dd>relative magnitude of noise, i.e. SNR = Ex/En</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>None</code> or <code>str</code>, optional</dt>
<dd>if "dB", SNR is specified in dB, i.e. SNR = 10*log(Ex/En).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ndarray</code></strong></dt>
<dd>data with noise</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_noise(self, snr, unit=None):
    &#34;&#34;&#34;Add noise to x with relative noise level SNR.

    Parameters
    ----------
    x : ndarray
        data
    SNR : float
        relative magnitude of noise, i.e. SNR = Ex/En
    unit : None or str, optional
        if &#34;dB&#34;, SNR is specified in dB, i.e. SNR = 10*log(Ex/En).

    Returns
    -------
    ndarray
        data with noise

    &#34;&#34;&#34;
    return self.from_time(self.fs, noisify(self.in_time, snr, unit=unit))</code></pre>
</details>
</dd>
<dt id="response.Response.circdelay"><code class="name flex">
<span>def <span class="ident">circdelay</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Delay by circular shift.</p>
<p>Rounds of to closest integer delay.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def circdelay(self, dt):
    &#34;&#34;&#34;Delay by circular shift.

    Rounds of to closest integer delay.
    &#34;&#34;&#34;
    x = self.in_time
    n = int(round(dt * self.fs))
    shifted = np.roll(x, n, axis=-1)

    return self.from_time(self.fs, shifted)</code></pre>
</details>
</dd>
<dt id="response.Response.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>self, dt, keep_length=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Delay time response by dt seconds.</p>
<p>Rounds of to closest integer delay.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delay(self, dt, keep_length=True):
    &#34;&#34;&#34;Delay time response by dt seconds.

    Rounds of to closest integer delay.
    &#34;&#34;&#34;
    x = delay(self.fs, self.in_time, dt, keep_length=keep_length)
    return self.from_time(self.fs, x)</code></pre>
</details>
</dd>
<dt id="response.Response.export_wav"><code class="name flex">
<span>def <span class="ident">export_wav</span></span>(<span>self, folder, name_fmt=&#39;{:02d}.wav&#39;, dtype=&lt;class &#39;numpy.int16&#39;&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Export response to wave file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;<code>file</code> <code>path</code></dt>
<dd>Save in this folder</dd>
<dt><strong><code>name_fmt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Format string for file names with one placeholder, e.g. 'filt1{:02d}.wav'.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def export_wav(self, folder, name_fmt=&#34;{:02d}.wav&#34;, dtype=np.int16):
    &#34;&#34;&#34;Export response to wave file.

    Parameters
    ----------
    folder : file path
        Save in this folder
    name_fmt : str, optional
        Format string for file names with one placeholder, e.g. &#39;filt1{:02d}.wav&#39;.

    &#34;&#34;&#34;
    data = np.atleast_2d(self.in_time)

    assert data.ndim == 2
    assert np.all(np.abs(data) &lt;= 1.0)

    # convert and scale to new output datatype
    lim_orig = (-1.0, 1.0)
    lim_new = (np.iinfo(dtype).min, np.iinfo(dtype).max)
    data = rescale(data, lim_orig, lim_new).astype(dtype)

    for i in range(data.shape[0]):
        fp = Path(folder) / name_fmt.format(i + 1)
        wavfile.write(fp, self.fs, data[i])</code></pre>
</details>
</dd>
<dt id="response.Response.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, b, a)</span>
</code></dt>
<dd>
<section class="desc"><p>Filter response along one-dimension with an IIR or FIR filter.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def filter(self, b, a):
    &#34;&#34;&#34;Filter response along one-dimension with an IIR or FIR filter.&#34;&#34;&#34;
    return self.from_time(self.fs, lfilter(b, a, self.in_time, axis=-1))</code></pre>
</details>
</dd>
<dt id="response.Response.freq_window"><code class="name flex">
<span>def <span class="ident">freq_window</span></span>(<span>self, startwindow, stopwindow, window=&#39;hann&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply frequency domain window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>startwindow</code></strong> :&ensp;<code>None</code> or <code>tuple</code></dt>
<dd>Tuple (t1, t2) with beginning and end frequencies of window opening.</dd>
<dt><strong><code>stopwindow</code></strong> :&ensp;<code>None</code> or <code>tuple</code></dt>
<dd>Tuple (t1, t2) with beginning and end frequencies of window closing.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>string</code> or <code>tuple</code> of <code>string</code> <code>and</code> <code>parameter</code> <code>values</code>, optional</dt>
<dd>Desired window to use. See scipy.signal.get_window for a list of
windows and required parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>Frequency windowed response object</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def freq_window(self, startwindow, stopwindow, window=&#34;hann&#34;):
    &#34;&#34;&#34;Apply frequency domain window.

    Parameters
    ----------
    startwindow : None or tuple
        Tuple (t1, t2) with beginning and end frequencies of window opening.
    stopwindow : None or tuple
        Tuple (t1, t2) with beginning and end frequencies of window closing.
    window : string or tuple of string and parameter values, optional
        Desired window to use. See scipy.signal.get_window for a list of
        windows and required parameters.

    Returns
    -------
    Response
        Frequency windowed response object

    &#34;&#34;&#34;
    n = self.times.size
    fwindow = freq_window(self.fs, n, startwindow, stopwindow, window=window)
    new_response = self.from_freq(self.fs, self.in_freq * fwindow)

    return new_response</code></pre>
</details>
</dd>
<dt id="response.Response.lowpass_by_frequency_domain_window"><code class="name flex">
<span>def <span class="ident">lowpass_by_frequency_domain_window</span></span>(<span>self, fstart, fstop)</span>
</code></dt>
<dd>
<section class="desc"><p>Lowpass response by time domain window.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def lowpass_by_frequency_domain_window(self, fstart, fstop):
    &#34;&#34;&#34;Lowpass response by time domain window.&#34;&#34;&#34;
    h = lowpass_by_frequency_domain_window(self.fs, self.in_time, fstart, fstop)
    return self.from_time(self.fs, h)</code></pre>
</details>
</dd>
<dt id="response.Response.non_causal_timecrop"><code class="name flex">
<span>def <span class="ident">non_causal_timecrop</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<section class="desc"><p>Cut length of non-causal impulse response.</p>
<p>"FFT shift, cropping on both ends, iFFT shift"</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>final length in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>New Response object new length.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Can introduce delay pre-delay by a sample.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def non_causal_timecrop(self, length):
    &#34;&#34;&#34;Cut length of non-causal impulse response.

    &#34;FFT shift, cropping on both ends, iFFT shift&#34;

    Parameters
    ----------
    length : float
        final length in seconds

    Returns
    -------
    Response
        New Response object new length.

    Note
    ----
    Can introduce delay pre-delay by a sample.

    &#34;&#34;&#34;
    assert length &lt; self.time_length

    cut = (self.time_length - length) / 2

    _, i_start = find_nearest(self.times, cut)
    _, i_end = find_nearest(self.times, self.time_length - cut)

    h = np.fft.ifftshift(np.fft.fftshift(self.in_time)[..., i_start:i_end])

    new_response = self.from_time(self.fs, h)

    if new_response.time_length != length:
        w = f&#34;Could not precisely shrink to {length}s with fs = {self.fs}&#34;
        warnings.warn(w)

    return new_response</code></pre>
</details>
</dd>
<dt id="response.Response.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self, maxval=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalize time response.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def normalize(self, maxval=1):
    &#34;&#34;&#34;Normalize time response.&#34;&#34;&#34;
    h = self.in_time
    h /= np.abs(self.in_time).max()
    h *= maxval
    return self.from_time(self.fs, h)</code></pre>
</details>
</dd>
<dt id="response.Response.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, group_delay=False, slce=None, flim=None, dblim=None, tlim=None, grpdlim=None, dbref=1, show=False, use_fig=None, label=None, unwrap=False, **fig_kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the response in both domains.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>group_delay</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Display group delay instead of phase.</dd>
<dt><strong><code>slce</code></strong> :&ensp;<code>numpy.lib.index_tricks.IndexExpression</code></dt>
<dd>only plot subset of responses defined by a slice. Last
dimension (f, t) is always completely taken.</dd>
<dt><strong><code>flim</code></strong> :&ensp;<code>tuple</code> or <code>None</code>, optional</dt>
<dd>Frequency axes limits as tuple <code>(lower, upper)</code></dd>
<dt><strong><code>dblim</code></strong> :&ensp;<code>tuple</code> or <code>None</code>, optional</dt>
<dd>Magnitude axes limits as tuple <code>(lower, upper)</code></dd>
<dt><strong><code>tlim</code></strong> :&ensp;<code>tuple</code> or <code>None</code>, optional</dt>
<dd>Time axes limits as tuple <code>(lower, upper)</code></dd>
<dt><strong><code>dbref</code></strong> :&ensp;<code>float</code></dt>
<dd>dB reference in magnitude plot</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Run <code>matplotlib.pyplot.show()</code></dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Reuse an existing figure.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>None</code>, optional</dt>
<dd>Description</dd>
<dt><strong><code>unwrap_phase</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>unwrap phase in phase plot</dd>
<dt><strong><code>**fig_kw</code></strong></dt>
<dd>Additional options passe to figure creation.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot(
    self,
    group_delay=False,
    slce=None,
    flim=None,
    dblim=None,
    tlim=None,
    grpdlim=None,
    dbref=1,
    show=False,
    use_fig=None,
    label=None,
    unwrap=False,
    **fig_kw,
):
    &#34;&#34;&#34;Plot the response in both domains.

    Parameters
    ----------
    group_delay : bool, optional
        Display group delay instead of phase.
    slce : numpy.lib.index_tricks.IndexExpression
        only plot subset of responses defined by a slice. Last
        dimension (f, t) is always completely taken.
    flim : tuple or None, optional
        Frequency axes limits as tuple `(lower, upper)`
    dblim : tuple or None, optional
        Magnitude axes limits as tuple `(lower, upper)`
    tlim : tuple or None, optional
        Time axes limits as tuple `(lower, upper)`
    dbref : float
        dB reference in magnitude plot
    show : bool, optional
        Run `matplotlib.pyplot.show()`
    fig : matplotlib.pyplot.Figure
        Reuse an existing figure.
    label : None, optional
        Description
    unwrap_phase : bool, optional
        unwrap phase in phase plot
    **fig_kw
        Additional options passe to figure creation.

    &#34;&#34;&#34;
    if use_fig is None:
        fig_kw = {**{&#34;figsize&#34;: (10, 10)}, **fig_kw}
        fig, axes = plt.subplots(nrows=3, constrained_layout=True, **fig_kw)
    else:
        fig = use_fig
        axes = fig.axes

    self.plot_magnitude(
        use_ax=axes[0], slce=slce, dblim=dblim, flim=flim, dbref=dbref, label=label
    )
    if group_delay:
        self.plot_group_delay(use_ax=axes[1], slce=slce, flim=flim, ylim=grpdlim)
    else:
        self.plot_phase(use_ax=axes[1], slce=slce, flim=flim)
    self.plot_time(use_ax=axes[2], tlim=tlim, slce=slce, unwrap=unwrap)

    if show:
        plt.show()

    return fig</code></pre>
</details>
</dd>
<dt id="response.Response.plot_group_delay"><code class="name flex">
<span>def <span class="ident">plot_group_delay</span></span>(<span>self, use_ax=None, slce=None, flim=None, label=None, ylim=None, **fig_kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot group delay.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_group_delay(
    self, use_ax=None, slce=None, flim=None, label=None, ylim=None, **fig_kw
):
    &#34;&#34;&#34;Plot group delay.&#34;&#34;&#34;
    if use_ax is None:
        fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
        fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
    else:
        ax = use_ax
        fig = ax.get_figure()

    # append frequency/time dimension to slice
    if slce is None:
        slce = [np.s_[:] for n in range(len(self.in_time.shape))]
    elif isinstance(slce, tuple):
        slce = slce + (np.s_[:],)
    else:
        slce = (slce, np.s_[:])

    # move time / frequency axis to first dimension
    freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
        (self.nf, -1)
    )

    df = self.freqs[1] - self.freqs[0]
    grpd = -np.gradient(np.unwrap(np.angle(freq_plotready)), df, axis=0)

    ax.semilogx(self.freqs, grpd)
    ax.set_xlabel(&#34;Frequency [Hz]&#34;)
    ax.set_ylabel(&#34;Delay [s]&#34;)
    ax.set_title(&#34;Group Delay&#34;)
    ax.grid(True)
    if flim is None:
        flim = (10, self.fs / 2)
    ax.set_xlim(flim)
    if ylim:
        ax.set_ylim(ylim)

    return fig</code></pre>
</details>
</dd>
<dt id="response.Response.plot_magnitude"><code class="name flex">
<span>def <span class="ident">plot_magnitude</span></span>(<span>self, use_ax=None, slce=None, dblim=None, flim=None, dbref=1, label=None, **fig_kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot magnitude response.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_magnitude(
    self,
    use_ax=None,
    slce=None,
    dblim=None,
    flim=None,
    dbref=1,
    label=None,
    **fig_kw,
):
    &#34;&#34;&#34;Plot magnitude response.&#34;&#34;&#34;
    if use_ax is None:
        fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
        fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
    else:
        ax = use_ax
        fig = ax.get_figure()

    # append frequency/time dimension to slice
    if slce is None:
        slce = [np.s_[:] for n in range(len(self.in_time.shape))]
    elif isinstance(slce, tuple):
        slce = slce + (np.s_[:],)
    else:
        slce = (slce, np.s_[:])

    unit = &#34; &#34; + self._unit if self._unit else &#34;&#34;

    # move time / frequency axis to first dimension
    freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
        (self.nf, -1)
    )

    ax.semilogx(
        self.freqs, 20 * np.log10(np.abs(freq_plotready / dbref)), label=label
    )
    ax.set_xlabel(&#34;Frequency [Hz]&#34;)
    ax.set_ylabel(&#34;Magnitude [dB re {:.2}{}]&#34;.format(float(dbref), unit))
    ax.set_title(&#34;Frequency response&#34;)
    ax.grid(True)

    if flim is None:
        flim = (10, self.fs / 2)
    ax.set_xlim(flim)

    return fig</code></pre>
</details>
</dd>
<dt id="response.Response.plot_phase"><code class="name flex">
<span>def <span class="ident">plot_phase</span></span>(<span>self, use_ax=None, slce=None, flim=None, label=None, unwrap=False, ylim=None, **fig_kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot phase response.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_phase(
    self,
    use_ax=None,
    slce=None,
    flim=None,
    label=None,
    unwrap=False,
    ylim=None,
    **fig_kw,
):
    &#34;&#34;&#34;Plot phase response.&#34;&#34;&#34;
    if use_ax is None:
        fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
        fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
    else:
        ax = use_ax
        fig = ax.get_figure()

    # append frequency/time dimension to slice
    if slce is None:
        slce = [np.s_[:] for n in range(len(self.in_time.shape))]
    elif isinstance(slce, tuple):
        slce = slce + (np.s_[:],)
    else:
        slce = (slce, np.s_[:])

    # move time / frequency axis to first dimension
    freq_plotready = np.rollaxis(self.in_freq[tuple(slce)], -1).reshape(
        (self.nf, -1)
    )
    phase = (
        np.unwrap(np.angle(freq_plotready)) if unwrap else np.angle(freq_plotready)
    )

    ax.semilogx(self.freqs, phase)
    ax.set_xlabel(&#34;Frequency [Hz]&#34;)
    ax.set_ylabel(&#34;Phase [rad]&#34;)
    ax.set_title(&#34;Phase response&#34;)
    ax.grid(True)

    if flim is None:
        flim = (10, self.fs / 2)
    ax.set_xlim(flim)
    if ylim:
        ax.set_ylim(ylim)

    return fig</code></pre>
</details>
</dd>
<dt id="response.Response.plot_power_in_bands"><code class="name flex">
<span>def <span class="ident">plot_power_in_bands</span></span>(<span>self, bands=None, use_ax=None, barkwargs={}, avgaxis=None, dbref=1, **figkwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot signal's power in bands.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bands</code></strong> :&ensp;<code>list</code> or <code>None</code>, optional</dt>
<dd>list of tuples (f_center, f_lower, f_upper)</dd>
<dt><strong><code>**figkwargs</code></strong></dt>
<dd>Keyword arguments passed to plt.subplots</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple (P, fc, fig)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_power_in_bands(
    self, bands=None, use_ax=None, barkwargs={}, avgaxis=None, dbref=1, **figkwargs
):
    &#34;&#34;&#34;Plot signal&#39;s power in bands.

    Parameters
    ----------
    bands : list or None, optional
        list of tuples (f_center, f_lower, f_upper)
    **figkwargs
        Keyword arguments passed to plt.subplots

    Returns
    -------
    tuple (P, fc, fig)

    &#34;&#34;&#34;
    P, fc = self.power_in_bands(bands=bands, avgaxis=avgaxis)

    nbands = P.shape[-1]
    P = np.atleast_2d(P).reshape((-1, nbands))

    if use_ax is None:
        fig, ax = plt.subplots(**figkwargs)
    else:
        ax = use_ax
        fig = ax.get_figure()

    xticks = range(1, nbands + 1)
    for i in range(P.shape[0]):
        ax.bar(xticks, 10 * np.log10(P[i] / dbref ** 2), **barkwargs)
    ax.set_xticks(xticks)
    ax.set_xticklabels([&#34;{:.0f}&#34;.format(f) for f in fc], rotation=&#34;vertical&#34;)
    ax.grid(True)
    ax.set_xlabel(&#34;Band&#39;s center frequencies [Hz]&#34;)
    ax.set_ylabel(&#34;Power [dB]&#34;)

    return fig</code></pre>
</details>
</dd>
<dt id="response.Response.plot_time"><code class="name flex">
<span>def <span class="ident">plot_time</span></span>(<span>self, use_ax=None, slce=None, tlim=None, ylim=None, **fig_kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot time response.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_time(self, use_ax=None, slce=None, tlim=None, ylim=None, **fig_kw):
    &#34;&#34;&#34;Plot time response.&#34;&#34;&#34;
    if use_ax is None:
        fig_kw = {**{&#34;figsize&#34;: (10, 5)}, **fig_kw}
        fig, ax = plt.subplots(nrows=1, constrained_layout=True, **fig_kw)
    else:
        ax = use_ax
        fig = ax.get_figure()

    # append frequency/time dimension to slice
    if slce is None:
        slce = [np.s_[:] for n in range(len(self.in_time.shape))]
    elif isinstance(slce, tuple):
        slce = slce + (np.s_[:],)
    else:
        slce = (slce, np.s_[:])

    time_plotready = np.rollaxis(self.in_time[tuple(slce)], -1).reshape(
        (self.nt, -1)
    )

    ax.plot(self.times, time_plotready)
    ax.set_xlabel(&#34;Time [s]&#34;)
    ax.set_ylabel(&#34;&#34;)
    ax.set_title(&#34;Time response&#34;)
    ax.grid(True)
    if tlim:
        ax.set_xlim(tlim)
    if ylim:
        ax.set_ylim(ylim)

    return fig</code></pre>
</details>
</dd>
<dt id="response.Response.power_in_bands"><code class="name flex">
<span>def <span class="ident">power_in_bands</span></span>(<span>self, bands=None, avgaxis=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute power of signal in third octave bands.</p>
<p>Power(band) =
1/T
integral
|X(f)| ** 2 df
f in band</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bands</code></strong> :&ensp;<code>list</code> of <code>tuples</code>, <code>length</code> <code>nbands</code> optional</dt>
<dd>Center, lower and upper frequencies of bands.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ndarray, shape (&hellip;, nbands)
Power in bands</p>
<p>list, length nbands
Center frequencies of bands</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def power_in_bands(self, bands=None, avgaxis=None):
    &#34;&#34;&#34;Compute power of signal in third octave bands.

    Power(band) =   1/T  integral  |X(f)| ** 2 df
                        f in band

    Parameters
    ----------
    bands : list of tuples, length nbands optional
        Center, lower and upper frequencies of bands.

    Returns
    -------
    ndarray, shape (..., nbands)
        Power in bands

    list, length nbands
        Center frequencies of bands

    &#34;&#34;&#34;
    if bands is None:
        bands = third_octave_bands

    shape = list(self.in_freq.shape)
    shape[-1] = len(bands)
    P = np.zeros(shape)
    fcs = np.asarray([b[0] for b in bands])
    Npow2 = 2 ** (self.nt - 1).bit_length()
    f = np.fft.fftfreq(Npow2, d=1 / self.fs)
    for i, (fc, fl, fu) in enumerate(bands):
        if fu &lt; self.fs / 2:  # include only bands in frequency range
            iband = np.logical_and(fl &lt;= f, f &lt; fu)
            P[..., i] = np.sum(
                np.abs(np.fft.fft(self.in_time, n=Npow2, axis=-1)[..., iband]) ** 2
                * 2  # energy from negative and positive frequencies
                * self.dt
                / self.nt
                / self.time_length,
                axis=-1,
            )
        else:
            P[..., i] = 0

    if avgaxis is not None:
        P = P.mean(axis=avgaxis)

    return P, fcs</code></pre>
</details>
</dd>
<dt id="response.Response.psd"><code class="name flex">
<span>def <span class="ident">psd</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the power spectral density of the signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>keword arguments passed to scipy.signal.welch</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of sample frequencies.</dd>
<dt><strong><code>Pxx</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Power spectral density of time signal.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Use scaling='density' for power per bin bandwidth and scaling='spectrum' for
power per bin.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def psd(self, **kwargs):
    &#34;&#34;&#34;Compute the power spectral density of the signal.

    Parameters
    ----------
    kwargs
        keword arguments passed to scipy.signal.welch

    Returns
    -------
    f : ndarray
        Array of sample frequencies.
    Pxx : ndarray
        Power spectral density of time signal.

    Notes
    -----
    Use scaling=&#39;density&#39; for power per bin bandwidth and scaling=&#39;spectrum&#39; for
    power per bin.

    &#34;&#34;&#34;
    return welch(self.in_time, fs=self.fs, **kwargs)</code></pre>
</details>
</dd>
<dt id="response.Response.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>self, fs_new, normalize=&#39;same_gain&#39;, window=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Resample using Fourier method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fs_new</code></strong> :&ensp;<code>int</code></dt>
<dd>New sample rate</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If 'same_gain', normalize such that the gain is the same
as the original signal. If 'same_amplitude', amplitudes will be preserved.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>None</code>, optional</dt>
<dd>Passed to scipy.signal.resample.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>New resampled response object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>If resulting number of samples would be a non-integer.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def resample(self, fs_new, normalize=&#34;same_gain&#34;, window=None):
    &#34;&#34;&#34;Resample using Fourier method.

    Parameters
    ----------
    fs_new : int
        New sample rate
    normalize : str, optional
        If &#39;same_gain&#39;, normalize such that the gain is the same
        as the original signal. If &#39;same_amplitude&#39;, amplitudes will be preserved.
    window : None, optional
        Passed to scipy.signal.resample.

    Returns
    -------
    Response
        New resampled response object.

    Raises
    ------
    ValueError
        If resulting number of samples would be a non-integer.

    &#34;&#34;&#34;
    if fs_new == self.fs:
        return self

    nt_new = fs_new * self.time_length

    if nt_new % 1 != 0:
        raise ValueError(
            &#34;New number of samples must be integer, but is {}&#34;.format(nt_new)
        )

    nt_new = int(nt_new)

    h_new = resample(self.in_time, nt_new, axis=-1, window=window)

    if normalize == &#34;same_gain&#34;:
        h_new *= self.nt / nt_new
    elif normalize == &#34;same_amplitude&#34;:
        pass
    else:
        raise ValueError(
            &#34;Expected &#39;same_gain&#39; or &#39;same_amplitude&#39;, got %s&#34; % (normalize,)
        )

    return self.from_time(fs_new, h_new)</code></pre>
</details>
</dd>
<dt id="response.Response.resample_poly"><code class="name flex">
<span>def <span class="ident">resample_poly</span></span>(<span>self, fs_new, normalize=&#39;same_gain&#39;, window=(&#39;kaiser&#39;, 5.0))</span>
</code></dt>
<dd>
<section class="desc"><p>Resample using polyphase filtering.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fs_new</code></strong> :&ensp;<code>int</code></dt>
<dd>New sample rate</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If 'same_gain', normalize such that the gain is the same
as the original signal. If 'same_amplitude', amplitudes will be preserved.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>None</code>, optional</dt>
<dd>Passed to scipy.signal.resample_poly.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>New resampled response object.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def resample_poly(self, fs_new, normalize=&#34;same_gain&#34;, window=(&#34;kaiser&#34;, 5.0)):
    &#34;&#34;&#34;Resample using polyphase filtering.

    Parameters
    ----------
    fs_new : int
        New sample rate
    normalize : str, optional
        If &#39;same_gain&#39;, normalize such that the gain is the same
        as the original signal. If &#39;same_amplitude&#39;, amplitudes will be preserved.
    window : None, optional
        Passed to scipy.signal.resample_poly.

    Returns
    -------
    Response
        New resampled response object.

    &#34;&#34;&#34;
    if fs_new == self.fs:
        return self

    ratio = Fraction(fs_new, self.fs)
    up = ratio.numerator
    down = ratio.denominator

    if up &gt; 1000 or down &gt; 1000:
        print(&#34;Warning: resampling with high ratio {}/{}&#34;.format(up, down))

    h_new = resample_poly(self.in_time, up, down, axis=-1, window=window)

    if normalize == &#34;same_gain&#34;:
        h_new *= down / up
    elif normalize == &#34;same_amplitude&#34;:
        pass
    else:
        raise ValueError(
            &#34;Expected &#39;same_gain&#39; or &#39;same_amplitude&#39;, got %s&#34; % (normalize,)
        )

    return self.from_time(fs_new, h_new)</code></pre>
</details>
</dd>
<dt id="response.Response.time_window"><code class="name flex">
<span>def <span class="ident">time_window</span></span>(<span>self, startwindow, stopwindow, window=&#39;hann&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply time domain windows.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>startwindow</code></strong> :&ensp;<code>None</code> or <code>tuple</code></dt>
<dd>Tuple (t1, t2) with beginning and end times of window opening.</dd>
<dt><strong><code>stopwindow</code></strong> :&ensp;<code>None</code> or <code>tuple</code></dt>
<dd>Tuple (t1, t2) with beginning and end times of window closing.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>string</code> or <code>tuple</code> of <code>string</code> <code>and</code> <code>parameter</code> <code>values</code>, optional</dt>
<dd>Desired window to use. See scipy.signal.get_window for a list of
windows and required parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>Time windowed response object</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def time_window(self, startwindow, stopwindow, window=&#34;hann&#34;):
    &#34;&#34;&#34;Apply time domain windows.

    Parameters
    ----------
    startwindow : None or tuple
        Tuple (t1, t2) with beginning and end times of window opening.
    stopwindow : None or tuple
        Tuple (t1, t2) with beginning and end times of window closing.
    window : string or tuple of string and parameter values, optional
        Desired window to use. See scipy.signal.get_window for a list of
        windows and required parameters.

    Returns
    -------
    Response
        Time windowed response object

    &#34;&#34;&#34;
    n = self.times.size
    twindow = time_window(self.fs, n, startwindow, stopwindow, window=window)
    new_response = self.from_time(self.fs, self.in_time * twindow)

    return new_response</code></pre>
</details>
</dd>
<dt id="response.Response.timecrop"><code class="name flex">
<span>def <span class="ident">timecrop</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<section class="desc"><p>Crop time response.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong>, <strong><code>end</code></strong> :&ensp;<code>float</code></dt>
<dd>Start and end times in seconds. Does not include sample at t=end. Use
end=None to force inclusion of last sample.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>New Response object with cropped time.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Creates new Response object.</p>
<p>The following should always hold:</p>
<pre><code>&gt;&gt;&gt; np.all(np.concatenate(
&gt;&gt;&gt;     (
&gt;&gt;&gt;         Response.from_time(fs, x).timecrop(0, split).in_time,
&gt;&gt;&gt;         Response.from_time(fs, x).timecrop(split, None).in_time,
&gt;&gt;&gt;     ),
&gt;&gt;&gt;     axis=-1,
&gt;&gt;&gt; ) == x)
</code></pre>
<p>True</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def timecrop(self, start, end):
    &#34;&#34;&#34;Crop time response.

    Parameters
    ----------
    start, end : float
        Start and end times in seconds. Does not include sample at t=end. Use
        end=None to force inclusion of last sample.

    Returns
    -------
    Response
        New Response object with cropped time.

    Notes
    -----
    Creates new Response object.

    The following should always hold:

    &gt;&gt;&gt; np.all(np.concatenate(
    &gt;&gt;&gt;     (
    &gt;&gt;&gt;         Response.from_time(fs, x).timecrop(0, split).in_time,
    &gt;&gt;&gt;         Response.from_time(fs, x).timecrop(split, None).in_time,
    &gt;&gt;&gt;     ),
    &gt;&gt;&gt;     axis=-1,
    &gt;&gt;&gt; ) == x)
    True

    &#34;&#34;&#34;
    if start &lt; 0:
        start += self.time_length
    if end is not None and end &lt; 0:
        end += self.time_length
    assert 0 &lt;= start &lt; self.time_length
    assert end is None or (0 &lt; end &lt;= self.time_length)

    _, i_start = find_nearest(self.times, start)
    if end is None:
        i_end = None
    else:
        _, i_end = find_nearest(self.times, end)

    print(i_start, i_end)

    h = self.in_time[..., i_start:i_end]

    new_response = self.from_time(self.fs, h)

    return new_response</code></pre>
</details>
</dd>
<dt id="response.Response.zeropad"><code class="name flex">
<span>def <span class="ident">zeropad</span></span>(<span>self, before, after)</span>
</code></dt>
<dd>
<section class="desc"><p>Zeropad time response.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>before</code></strong>, <strong><code>after</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of zero samples inserted before and after response.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>Zeropadded response</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def zeropad(self, before, after):
    &#34;&#34;&#34;Zeropad time response.

    Parameters
    ----------
    before, after : int
        Number of zero samples inserted before and after response.

    Returns
    -------
    Response
        Zeropadded response

    &#34;&#34;&#34;
    assert before % 1 == 0
    assert after % 1 == 0
    dims = self.in_time.ndim

    pad_width = [(0, 0) for n in range(dims)]
    pad_width[-1] = (int(before), int(after))

    h = np.pad(self.in_time, pad_width, &#34;constant&#34;)

    return self.from_time(self.fs, h)</code></pre>
</details>
</dd>
<dt id="response.Response.zeropad_to_length"><code class="name flex">
<span>def <span class="ident">zeropad_to_length</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"><p>Zeropad time response to length.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>New response object with new length n.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def zeropad_to_length(self, n):
    &#34;&#34;&#34;Zeropad time response to length.

    Returns
    -------
    Response
        New response object with new length n.

    &#34;&#34;&#34;
    oldn = self.nt
    assert n &gt;= oldn
    return self.zeropad(0, n - oldn)</code></pre>
</details>
</dd>
<dt id="response.Response.zeropad_to_power_of_2"><code class="name flex">
<span>def <span class="ident">zeropad_to_power_of_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Pad time response for length of power of 2.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="response.Response" href="#response.Response"><code>Response</code></a></strong></dt>
<dd>New response object with larger, power of 2 length.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def zeropad_to_power_of_2(self):
    &#34;&#34;&#34;Pad time response for length of power of 2.

    Returns
    -------
    Response
        New response object with larger, power of 2 length.

    &#34;&#34;&#34;
    # https://stackoverflow.com/questions/14267555/find-the-smallest-power-of-2-greater-than-n-in-python
    n = 2 ** (self.nt - 1).bit_length()
    return self.zeropad(0, n - self.nt)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="response.delay" href="#response.delay">delay</a></code></li>
<li><code><a title="response.find_nearest" href="#response.find_nearest">find_nearest</a></code></li>
<li><code><a title="response.freq_vector" href="#response.freq_vector">freq_vector</a></code></li>
<li><code><a title="response.freq_window" href="#response.freq_window">freq_window</a></code></li>
<li><code><a title="response.lowpass_by_frequency_domain_window" href="#response.lowpass_by_frequency_domain_window">lowpass_by_frequency_domain_window</a></code></li>
<li><code><a title="response.noisify" href="#response.noisify">noisify</a></code></li>
<li><code><a title="response.rescale" href="#response.rescale">rescale</a></code></li>
<li><code><a title="response.sample_window" href="#response.sample_window">sample_window</a></code></li>
<li><code><a title="response.time_vector" href="#response.time_vector">time_vector</a></code></li>
<li><code><a title="response.time_window" href="#response.time_window">time_window</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="response.Response" href="#response.Response">Response</a></code></h4>
<ul class="">
<li><code><a title="response.Response.__init__" href="#response.Response.__init__">__init__</a></code></li>
<li><code><a title="response.Response.add_noise" href="#response.Response.add_noise">add_noise</a></code></li>
<li><code><a title="response.Response.amplitude_spectrum" href="#response.Response.amplitude_spectrum">amplitude_spectrum</a></code></li>
<li><code><a title="response.Response.circdelay" href="#response.Response.circdelay">circdelay</a></code></li>
<li><code><a title="response.Response.delay" href="#response.Response.delay">delay</a></code></li>
<li><code><a title="response.Response.export_wav" href="#response.Response.export_wav">export_wav</a></code></li>
<li><code><a title="response.Response.filter" href="#response.Response.filter">filter</a></code></li>
<li><code><a title="response.Response.freq_vector" href="#response.Response.freq_vector">freq_vector</a></code></li>
<li><code><a title="response.Response.freq_window" href="#response.Response.freq_window">freq_window</a></code></li>
<li><code><a title="response.Response.freqs" href="#response.Response.freqs">freqs</a></code></li>
<li><code><a title="response.Response.from_freq" href="#response.Response.from_freq">from_freq</a></code></li>
<li><code><a title="response.Response.from_time" href="#response.Response.from_time">from_time</a></code></li>
<li><code><a title="response.Response.from_wav" href="#response.Response.from_wav">from_wav</a></code></li>
<li><code><a title="response.Response.fs" href="#response.Response.fs">fs</a></code></li>
<li><code><a title="response.Response.in_freq" href="#response.Response.in_freq">in_freq</a></code></li>
<li><code><a title="response.Response.in_time" href="#response.Response.in_time">in_time</a></code></li>
<li><code><a title="response.Response.join" href="#response.Response.join">join</a></code></li>
<li><code><a title="response.Response.lowpass_by_frequency_domain_window" href="#response.Response.lowpass_by_frequency_domain_window">lowpass_by_frequency_domain_window</a></code></li>
<li><code><a title="response.Response.new_dirac" href="#response.Response.new_dirac">new_dirac</a></code></li>
<li><code><a title="response.Response.nf" href="#response.Response.nf">nf</a></code></li>
<li><code><a title="response.Response.non_causal_timecrop" href="#response.Response.non_causal_timecrop">non_causal_timecrop</a></code></li>
<li><code><a title="response.Response.normalize" href="#response.Response.normalize">normalize</a></code></li>
<li><code><a title="response.Response.nt" href="#response.Response.nt">nt</a></code></li>
<li><code><a title="response.Response.plot" href="#response.Response.plot">plot</a></code></li>
<li><code><a title="response.Response.plot_group_delay" href="#response.Response.plot_group_delay">plot_group_delay</a></code></li>
<li><code><a title="response.Response.plot_magnitude" href="#response.Response.plot_magnitude">plot_magnitude</a></code></li>
<li><code><a title="response.Response.plot_phase" href="#response.Response.plot_phase">plot_phase</a></code></li>
<li><code><a title="response.Response.plot_power_in_bands" href="#response.Response.plot_power_in_bands">plot_power_in_bands</a></code></li>
<li><code><a title="response.Response.plot_time" href="#response.Response.plot_time">plot_time</a></code></li>
<li><code><a title="response.Response.power_in_bands" href="#response.Response.power_in_bands">power_in_bands</a></code></li>
<li><code><a title="response.Response.psd" href="#response.Response.psd">psd</a></code></li>
<li><code><a title="response.Response.resample" href="#response.Response.resample">resample</a></code></li>
<li><code><a title="response.Response.resample_poly" href="#response.Response.resample_poly">resample_poly</a></code></li>
<li><code><a title="response.Response.time_length" href="#response.Response.time_length">time_length</a></code></li>
<li><code><a title="response.Response.time_vector" href="#response.Response.time_vector">time_vector</a></code></li>
<li><code><a title="response.Response.time_window" href="#response.Response.time_window">time_window</a></code></li>
<li><code><a title="response.Response.timecrop" href="#response.Response.timecrop">timecrop</a></code></li>
<li><code><a title="response.Response.times" href="#response.Response.times">times</a></code></li>
<li><code><a title="response.Response.zeropad" href="#response.Response.zeropad">zeropad</a></code></li>
<li><code><a title="response.Response.zeropad_to_length" href="#response.Response.zeropad_to_length">zeropad_to_length</a></code></li>
<li><code><a title="response.Response.zeropad_to_power_of_2" href="#response.Response.zeropad_to_power_of_2">zeropad_to_power_of_2</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>